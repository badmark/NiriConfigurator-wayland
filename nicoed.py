#!/usr/bin/env python3
import sys
import os
import re
import subprocess
import glob
import shutil
import traceback
from pathlib import Path
from datetime import datetime

try:
    from PyQt5.QtWidgets import (
        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
        QTabWidget, QLabel, QLineEdit, QComboBox, QCheckBox, QPushButton, 
        QTextEdit, QPlainTextEdit, QSplitter, QTreeWidget, QTreeWidgetItem, 
        QHeaderView, QFormLayout, QScrollArea, QMessageBox, QFileDialog, 
        QColorDialog, QFrame, QSizePolicy, QAction
    )
    from PyQt5.QtCore import Qt, QRect, QSize, pyqtSignal, pyqtSlot
    from PyQt5.QtGui import QColor, QPainter, QTextFormat, QPalette, QFont
except ImportError:
    print("Error: PyQt5 not found. Please install it (e.g., 'sudo pacman -S python-pyqt5' or 'pip install PyQt5').")
    sys.exit(1)

# ==============================================================================
# DEFAULT CONFIGURATION
# ==============================================================================
DEFAULT_CONFIG = """
// Niri Default Configuration
// Auto-generated by NiCoEd

input {
    keyboard {
        xkb {
            layout "us"
        }
    }
    touchpad {
        tap
        natural-scroll
        dwt
    }
    focus-follows-mouse
}

output "eDP-1" {
    scale 1.0
    transform "normal"
    position x=0 y=0
}

layout {
    gaps 16
    center-focused-column "never"
    default-column-width { proportion 0.5; }

    preset-column-widths {
        proportion 0.33333
        proportion 0.5
        proportion 0.66667
    }

    focus-ring {
        width 4
        active-color "#7fc8ff"
        inactive-color "#505050"
    }

    border {
        off
        width 4
        active-color "#ffc87f"
        inactive-color "#505050"
    }
}

binds {
    Mod+Shift+E { quit; }
    Mod+Q { close-window; }
    Mod+Return { spawn "alacritty"; }
    Mod+D { spawn "fuzzel"; }
}
"""

# ==============================================================================
# LOGIC: Config Handler (Framework Independent)
# ==============================================================================
class NiriConfigHandler:
    def __init__(self):
        self.config_path = self.get_config_path()
        self.content = ""
        self.load_config()

    def get_config_path(self):
        return Path.home() / ".config" / "niri" / "config.kdl"

    def load_config(self, filepath=None):
        target = filepath if filepath else self.config_path
        if target.exists():
            with open(target, "r") as f:
                self.content = f.read()
            return True
        else:
            self.content = DEFAULT_CONFIG
            return False

    def save_config(self):
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, "w") as f:
            f.write(self.content)

    def create_backup(self):
        if not self.config_path.exists(): return None
        base_bak = self.config_path.with_name("config.kdl.bak")
        target_bak = base_bak
        count = 1
        while target_bak.exists():
            target_bak = self.config_path.with_name(f"config.kdl.bak{count}")
            count += 1
        try:
            shutil.copy2(self.config_path, target_bak)
            return target_bak.name
        except Exception as e:
            print(f"Backup failed: {e}")
            return None

    def list_configs(self):
        configs = []
        if self.config_path.exists():
            timestamp = datetime.fromtimestamp(self.config_path.stat().st_mtime).strftime("%H:%M:%S")
            configs.append((f"Current Config ({timestamp})", str(self.config_path)))
        parent = self.config_path.parent
        if parent.exists():
            backups = list(parent.glob("config.kdl.bak*"))
            backups.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            for bak in backups:
                ts = datetime.fromtimestamp(bak.stat().st_mtime).strftime("%Y-%m-%d %H:%M")
                configs.append((f"{bak.name} ({ts})", str(bak)))
        return configs

    def extract_block_content(self, text, block_name):
        pattern = re.compile(rf"\b{block_name}\b.*\{{")
        match = pattern.search(text)
        if not match: return None
        start_idx = match.start()
        open_brace_idx = match.end() - 1
        brace_count = 1
        i = open_brace_idx + 1
        while i < len(text) and brace_count > 0:
            if text[i] == '{': brace_count += 1
            elif text[i] == '}': brace_count -= 1
            i += 1
        if brace_count == 0: return (start_idx, i, text[open_brace_idx+1:i-1])
        return None

    def update_block(self, block_name, new_inner_content):
        result = self.extract_block_content(self.content, block_name)
        if result:
            start_idx, end_idx, _ = result
            brace_pos = self.content.find('{', start_idx)
            header = self.content[start_idx:brace_pos+1]
            self.content = self.content[:start_idx] + f"{header}\n{new_inner_content}\n}}" + self.content[end_idx:]
        else:
            self.content += f"\n{block_name} {{\n{new_inner_content}\n}}\n"

    def extract_repeated_blocks(self, block_name):
        blocks = []
        pattern = re.compile(rf'{block_name}\s+"([^"]+)"\s*\{{')
        text = self.content; search_start = 0
        while True:
            match = pattern.search(text, search_start)
            if not match: break
            name = match.group(1); brace_open_idx = match.end() - 1; brace_count = 1; i = brace_open_idx + 1
            while i < len(text) and brace_count > 0:
                if text[i] == '{': brace_count += 1
                elif text[i] == '}': brace_count -= 1
                i += 1
            if brace_count == 0:
                end_idx = i; inner = text[brace_open_idx+1 : end_idx-1]
                blocks.append({'name': name, 'content': inner, 'span': (match.start(), end_idx)})
                search_start = end_idx
            else: break
        return blocks

    def replace_repeated_blocks(self, block_name, new_blocks_str):
        current_blocks = self.extract_repeated_blocks(block_name)
        current_blocks.sort(key=lambda x: x['span'][0], reverse=True)
        for b in current_blocks: self.content = self.content[:b['span'][0]] + self.content[b['span'][1]:]
        self.content = self.content.rstrip() + "\n\n" + new_blocks_str

    def extract_rules(self, rule_type):
        rules = []
        pattern = re.compile(rf'\n\s*{rule_type}\s*\{{')
        text = self.content; search_start = 0
        while True:
            match = pattern.search(text, search_start)
            if not match: break
            brace_open_idx = match.end() - 1; brace_count = 1; i = brace_open_idx + 1
            while i < len(text) and brace_count > 0:
                if text[i] == '{': brace_count += 1
                elif text[i] == '}': brace_count -= 1
                i += 1
            if brace_count == 0:
                end_idx = i; inner = text[brace_open_idx+1 : end_idx-1]
                rules.append({'content': inner, 'span': (match.start(), end_idx)})
                search_start = end_idx
            else: break
        return rules

    def replace_rules(self, rule_type, new_blocks_str):
        current_rules = self.extract_rules(rule_type)
        current_rules.sort(key=lambda x: x['span'][0], reverse=True)
        for r in current_rules: self.content = self.content[:r['span'][0]] + self.content[r['span'][1]:]
        self.content = self.content.rstrip() + "\n\n" + new_blocks_str

    # Wrappers
    def extract_all_outputs(self): return self.extract_repeated_blocks("output")
    def replace_outputs_section(self, s): self.replace_repeated_blocks("output", s)
    def extract_named_workspaces(self): return self.extract_repeated_blocks("workspace")
    def replace_named_workspaces_section(self, s): self.replace_repeated_blocks("workspace", s)
    def extract_window_rules(self): return self.extract_rules("window-rule")
    def replace_window_rules_section(self, s): self.replace_rules("window-rule", s)
    def extract_layer_rules(self): return self.extract_rules("layer-rule")
    def replace_layer_rules_section(self, s): self.replace_rules("layer-rule", s)
    
    def extract_spawn_actions(self):
        actions = []
        pattern = re.compile(r'^\s*(spawn-at-startup|spawn-sh-at-startup)\s+(?:\"([^\"]*)\"|([^;\s]+))', re.MULTILINE)
        for m in pattern.finditer(self.content):
            actions.append({'type': m.group(1), 'command': m.group(2) or m.group(3)})
        return actions

    def replace_spawn_actions(self, new_actions):
        self.content = re.sub(r'^\s*(spawn-at-startup|spawn-sh-at-startup)\s+.*(\r\n|\r|\n)?', '', self.content, flags=re.MULTILINE)
        new_block = "\n"
        for act in new_actions: new_block += f"{act['type']} \"{act['command']}\"\n"
        self.content += new_block

    def extract_environment_vars(self):
        vars_list = []
        result = self.extract_block_content(self.content, "environment")
        if not result: return []
        for line in result[2].split('\n'):
            line = line.strip().strip(';')
            if not line or line.startswith("//"): continue
            parts = line.split(maxsplit=1)
            if len(parts) == 2: vars_list.append({'name': parts[0], 'value': parts[1].strip('"')})
        return vars_list

    def replace_environment_section(self, vars_list):
        inner = ""
        for v in vars_list: inner += f"    {v['name']} \"{v['value']}\"\n"
        self.update_block("environment", inner)

    def extract_includes(self):
        return [m.group(1) for m in re.finditer(r'^\s*include\s+"([^"]+)"', self.content, re.MULTILINE)]

    def replace_includes(self, new_includes):
        self.content = re.sub(r'^\s*include\s+"[^"]+".*(\r\n|\r|\n)?', '', self.content, flags=re.MULTILINE)
        block = ""
        for inc in new_includes: block += f'include "{inc}"\n'
        self.content = block + "\n" + self.content.strip()

    def get_value(self, path, key, default):
        current_text = self.content
        if path:
            blocks = path.split(".")
            for b in blocks:
                result = self.extract_block_content(current_text, b)
                if result: _, _, inner = result; current_text = inner
                else: return default
        match = re.search(rf"\b{key}\s+(?:\"([^\"]*)\"|([^;\s]+))", current_text)
        if match: return match.group(1) if match.group(1) is not None else match.group(2)
        if default in ["true", "false"]: return "true" if re.search(rf"\b{key}[;\s]", current_text) else "false"
        return default

    def set_value(self, path, key, value, is_string=False):
        self.content = self._update_recursive(self.content, path.split(".") if path else [], key, value, is_string)

    def _update_recursive(self, text, block_path, key, value, is_string):
        if not block_path:
            val_str = f'"{value}"' if is_string else str(value)
            if value.lower() == "true" and not is_string:
                if not re.search(rf"\b{key}[;\s]", text): return text.rstrip() + f"\n    {key};\n"
                return text 
            elif value.lower() == "false" and not is_string:
                return re.sub(rf"\s*{key}[;\s]", "", text)
            line = f"    {key} {val_str};\n"
            if re.search(rf"(\b{key}\s+)[^;]+;", text): return re.sub(rf"(\b{key}\s+)[^;]+;", rf"\1{val_str};", text)
            else: return text.rstrip() + "\n" + line

        current = block_path[0]
        result = self.extract_block_content(text, current)
        if result:
            s, e, inner = result
            new_inner = self._update_recursive(inner, block_path[1:], key, value, is_string)
            header = text[s : text.find('{', s)+1]
            return text[:s] + f"{header}{new_inner}}}" + text[e:]
        else:
            child = self._create_new_block(block_path[1:], key, value, is_string)
            return text + f"\n{current} {{\n{child}}}\n"

    def _create_new_block(self, block_path, key, value, is_string):
        if not block_path:
            val_str = f'"{value}"' if is_string else str(value)
            if value.lower() == "true": return f"    {key};\n"
            if value.lower() == "false": return ""
            return f"    {key} {val_str};\n"
        current = block_path[0]
        inner = self._create_new_block(block_path[1:], key, value, is_string)
        return f"    {current} {{\n{inner}    }}\n"

# ==============================================================================
# Hardware Info
# ==============================================================================
class SystemInfo:
    @staticmethod
    def get_connected_outputs():
        outputs = []
        try:
            res = subprocess.run(['niri', 'msg', '-j', 'outputs'], capture_output=True, text=True, timeout=1)
            if res.returncode == 0:
                import json; data = json.loads(res.stdout)
                for name in data.keys(): outputs.append(name)
        except: pass
        return outputs if outputs else ["eDP-1", "HDMI-A-1"]
    
    @staticmethod
    def get_drm_devices(): return glob.glob("/dev/dri/card*") or ["/dev/dri/card0"]

    @staticmethod
    def get_installed_cursor_themes():
        themes = set()
        for p in [Path.home()/".icons", Path.home()/".local/share/icons", Path("/usr/share/icons")]:
            if p.exists():
                for i in p.iterdir():
                    if (i/"cursors").exists() or (i/"index.theme").exists(): themes.add(i.name)
        return sorted(list(themes)) if themes else ["Adwaita", "default"]

# ==============================================================================
# CUSTOM WIDGETS
# ==============================================================================
class LineNumberArea(QWidget):
    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor

    def sizeHint(self):
        return QSize(self.editor.lineNumberAreaWidth(), 0)

    def paintEvent(self, event):
        self.editor.lineNumberAreaPaintEvent(event)

class CodeEditor(QPlainTextEdit):
    def __init__(self):
        super().__init__()
        self.lineNumberArea = LineNumberArea(self)
        self.blockCountChanged.connect(self.updateLineNumberAreaWidth)
        self.updateRequest.connect(self.updateLineNumberArea)
        self.cursorPositionChanged.connect(self.highlightCurrentLine)
        self.updateLineNumberAreaWidth(0)
        self.highlightCurrentLine()

        font = QFont("Monospace")
        font.setStyleHint(QFont.TypeWriter)
        self.setFont(font)

    def lineNumberAreaWidth(self):
        digits = 1
        max_val = max(1, self.blockCount())
        while max_val >= 10:
            max_val //= 10
            digits += 1
        space = 3 + self.fontMetrics().width('9') * digits
        return space

    def updateLineNumberAreaWidth(self, _):
        self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

    def updateLineNumberArea(self, rect, dy):
        if dy:
            self.lineNumberArea.scroll(0, dy)
        else:
            self.lineNumberArea.update(0, rect.y(), self.lineNumberArea.width(), rect.height())
        if rect.contains(self.viewport().rect()):
            self.updateLineNumberAreaWidth(0)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.lineNumberArea.setGeometry(QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height()))

    def lineNumberAreaPaintEvent(self, event):
        painter = QPainter(self.lineNumberArea)
        painter.fillRect(event.rect(), Qt.lightGray if not self.is_dark else QColor("#2d2d2d"))
        
        block = self.firstVisibleBlock()
        blockNumber = block.blockNumber()
        top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
        bottom = top + int(self.blockBoundingGeometry(block).height())

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(blockNumber + 1)
                painter.setPen(Qt.black if not self.is_dark else Qt.lightGray)
                painter.drawText(0, top, self.lineNumberArea.width(), self.fontMetrics().height(),
                                 Qt.AlignRight, number)
            block = block.next()
            top = bottom
            bottom = top + int(self.blockBoundingGeometry(block).height())
            blockNumber += 1

    def highlightCurrentLine(self):
        extraSelections = []
        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            lineColor = QColor(Qt.yellow).lighter(160) if not self.is_dark else QColor("#3d3d3d")
            selection.format.setBackground(lineColor)
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extraSelections.append(selection)
        self.setExtraSelections(extraSelections)
    
    is_dark = False
    def set_theme(self, is_dark):
        self.is_dark = is_dark
        p = self.palette()
        if is_dark:
            p.setColor(QPalette.Base, QColor("#1e1e1e"))
            p.setColor(QPalette.Text, QColor("#ffffff"))
        else:
            p.setColor(QPalette.Base, QColor("#ffffff"))
            p.setColor(QPalette.Text, QColor("#000000"))
        self.setPalette(p)
        self.highlightCurrentLine()
        self.update()


# ==============================================================================
# GUI: Main Window (PyQt5)
# ==============================================================================
class NiriWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("NiCoEd - Niri Config Editor")
        self.resize(1200, 850)
        
        self.handler = NiriConfigHandler()
        self.widget_map = {}
        self.outputs_data = []
        self.binds_data = []
        
        self.sys_outputs = SystemInfo.get_connected_outputs()
        self.sys_cursors = SystemInfo.get_installed_cursor_themes()
        
        # Central Widget
        self.central_widget = QWidget()
        self.setCentralWidget(self.central_widget)
        self.main_layout = QVBoxLayout(self.central_widget)
        
        # Tabs
        self.tabs = QTabWidget()
        self.main_layout.addWidget(self.tabs)
        
        # Info Panel (Bottom)
        self.info_frame = QFrame()
        self.info_layout = QHBoxLayout(self.info_frame)
        self.lbl_info = QLabel("Overview: Select a tab.")
        self.info_layout.addWidget(self.lbl_info)
        self.main_layout.addWidget(self.info_frame)
        
        # Buttons
        self.btn_layout = QHBoxLayout()
        self.btn_theme = QPushButton("ðŸŒ— Theme")
        self.btn_theme.clicked.connect(self.toggle_theme)
        self.btn_load = QComboBox()
        self.btn_load.currentIndexChanged.connect(self.on_config_selected)
        self.btn_reload = QPushButton("Reload")
        self.btn_reload.clicked.connect(self.reload_settings)
        self.btn_save = QPushButton("Save All")
        self.btn_save.clicked.connect(self.prompt_save)
        
        self.btn_layout.addWidget(self.btn_theme)
        self.btn_layout.addWidget(QLabel("Load:"))
        self.btn_layout.addWidget(self.btn_load)
        self.btn_layout.addStretch()
        self.btn_layout.addWidget(self.btn_reload)
        self.btn_layout.addWidget(self.btn_save)
        self.main_layout.addLayout(self.btn_layout)
        
        self.init_tabs()
        self.update_config_list()
        self.is_dark = False
        self.apply_theme()

    def init_tabs(self):
        self.create_input_tab()
        self.create_outputs_tab()
        self.create_layout_tab()
        self.create_workspaces_tab()
        self.create_cursor_tab()
        self.create_window_rules_tab()
        self.create_layer_rules_tab()
        self.create_animations_tab()
        self.create_misc_tab()
        self.create_environment_tab()
        self.create_debug_tab()
        self.create_binds_tab()
        self.create_switches_tab()
        self.create_gestures_tab()
        self.create_recent_windows_tab()
        self.create_includes_tab()
        self.create_raw_tab()

    # --- Tab Helpers ---
    def add_tab(self, widget, title, desc):
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setWidget(widget)
        self.tabs.addTab(scroll, title)
        # Store desc? simpler to use index/switch
        
    def create_form_row(self, layout, label, path, key, default, is_bool=False, options=None, is_color=False, is_file=False):
        lbl = QLabel(label)
        val = self.handler.get_value(path, key, default)
        
        if is_bool:
            widget = QCheckBox()
            widget.setChecked(val.lower() == "true")
            getter = lambda: "true" if widget.isChecked() else "false"
        elif options:
            widget = QComboBox()
            widget.addItems(options)
            widget.setCurrentText(val)
            getter = lambda: widget.currentText()
        else:
            widget = QLineEdit(str(val))
            getter = lambda: widget.text()
            
        container = QWidget()
        h_lay = QHBoxLayout(container)
        h_lay.setContentsMargins(0,0,0,0)
        h_lay.addWidget(widget)
        
        if is_color:
            btn = QPushButton("ðŸŽ¨")
            btn.clicked.connect(lambda: self.pick_color(widget))
            h_lay.addWidget(btn)
        if is_file:
            btn = QPushButton("ðŸ“‚")
            btn.clicked.connect(lambda: self.pick_file(widget))
            h_lay.addWidget(btn)
            
        layout.addRow(lbl, container)
        self.widget_map[f"{path}:{key}"] = (widget, getter)

    # --- Pickers ---
    def pick_color(self, widget):
        col = QColorDialog.getColor()
        if col.isValid(): widget.setText(col.name())
    
    def pick_file(self, widget):
        fname, _ = QFileDialog.getOpenFileName(self, "Select File")
        if fname: widget.setText(fname)

    # --- Tab Content ---
    def create_input_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Warn Keymap", "input", "warn-no-keymap", "false", is_bool=True)
        self.add_tab(w, "Input", "Input settings")

    def create_outputs_tab(self):
        splitter = QSplitter(Qt.Horizontal)
        
        # Left: List
        self.out_list = QTreeWidget()
        self.out_list.setHeaderLabels(["Output"])
        self.out_list.itemSelectionChanged.connect(self.on_output_select)
        splitter.addWidget(self.out_list)
        
        # Right: Form
        w = QWidget(); l = QFormLayout(w)
        # Simplified dynamic fields for now. Real impl would map selection to these.
        self.out_mode = QComboBox(); self.out_mode.addItems(["1920x1080", "3840x2160"])
        l.addRow("Mode", self.out_mode)
        
        btn = QPushButton("Update Selected"); btn.clicked.connect(self.update_output_mem)
        l.addRow(btn)
        
        splitter.addWidget(w)
        self.add_tab(splitter, "Outputs", "Monitors")
        self.load_outputs_tree()

    def load_outputs_tree(self):
        self.out_list.clear()
        self.outputs_data = self.handler.extract_all_outputs()
        for o in self.outputs_data:
            QTreeWidgetItem(self.out_list, [o['name']])

    def on_output_select(self):
        pass # Logic to fill form from self.outputs_data based on selection

    def update_output_mem(self):
        pass # Logic to save form back to memory

    # ... [Repeated pattern for other tabs using QFormLayout and QSplitter] ...
    def create_layout_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Gaps", "layout", "gaps", "16")
        self.create_form_row(l, "Border Width", "layout.border", "width", "4")
        self.create_form_row(l, "Active Color", "layout.border", "active-color", "#ff0000", is_color=True)
        self.add_tab(w, "Layout", "Layout")

    def create_workspaces_tab(self):
        w = QWidget(); l = QVBoxLayout(w); l.addWidget(QLabel("Workspaces (List logic needed)"))
        self.add_tab(w, "Workspaces", "Workspaces")

    def create_cursor_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Theme", "", "xcursor-theme", "", options=self.sys_cursors)
        self.create_form_row(l, "Size", "", "xcursor-size", "24")
        self.add_tab(w, "Cursor", "Cursor")

    def create_window_rules_tab(self): self.add_tab(QLabel("Rules Placeholder"), "Rules", "")
    def create_layer_rules_tab(self): self.add_tab(QLabel("Layers Placeholder"), "Layers", "")
    def create_animations_tab(self): self.add_tab(QLabel("Anims Placeholder"), "Anims", "")
    def create_misc_tab(self): self.add_tab(QLabel("Misc Placeholder"), "Misc", "")
    def create_environment_tab(self): self.add_tab(QLabel("Env Placeholder"), "Env", "")
    def create_includes_tab(self): self.add_tab(QLabel("Inc Placeholder"), "Inc", "")
    def create_debug_tab(self): self.add_tab(QLabel("Debug Placeholder"), "Debug", "")
    def create_binds_tab(self): self.add_tab(QLabel("Binds Placeholder"), "Binds", "")
    def create_switches_tab(self): self.add_tab(QLabel("Switches Placeholder"), "Switches", "")
    def create_gestures_tab(self): self.add_tab(QLabel("Gestures Placeholder"), "Gestures", "")
    def create_recent_windows_tab(self): self.add_tab(QLabel("Recent Placeholder"), "Recent", "")

    def create_raw_tab(self):
        self.raw_editor = CodeEditor()
        self.raw_editor.setPlainText(self.handler.content)
        self.add_tab(self.raw_editor, "Full Config", "Raw Text")

    # --- Actions ---
    def toggle_theme(self):
        self.is_dark = not self.is_dark
        self.apply_theme()
        if hasattr(self, 'raw_editor'): self.raw_editor.set_theme(self.is_dark)

    def apply_theme(self):
        palette = QPalette()
        if self.is_dark:
            palette.setColor(QPalette.Window, QColor(53, 53, 53))
            palette.setColor(QPalette.WindowText, Qt.white)
            palette.setColor(QPalette.Base, QColor(25, 25, 25))
            palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))
            palette.setColor(QPalette.ToolTipBase, Qt.white)
            palette.setColor(QPalette.ToolTipText, Qt.white)
            palette.setColor(QPalette.Text, Qt.white)
            palette.setColor(QPalette.Button, QColor(53, 53, 53))
            palette.setColor(QPalette.ButtonText, Qt.white)
            palette.setColor(QPalette.BrightText, Qt.red)
            palette.setColor(QPalette.Link, QColor(42, 130, 218))
            palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
            palette.setColor(QPalette.HighlightedText, Qt.black)
        else:
            # Default palette
            palette = QApplication.style().standardPalette()
        QApplication.setPalette(palette)

    def update_config_list(self):
        self.btn_load.clear()
        self.configs = self.handler.list_configs()
        for name, _ in self.configs: self.btn_load.addItem(name)

    def on_config_selected(self, idx):
        if idx >= 0:
            self.handler.load_config(Path(self.configs[idx][1]))
            self.reload_settings()

    def prompt_save(self):
        reply = QMessageBox.question(self, 'Save', 'Overwrite config?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.save_settings()

    def save_settings(self):
        # Update from widgets
        for key, (widget, getter) in self.widget_map.items():
            path, k = key.split(":")
            self.handler.set_value(path, k, getter())
            
        # Raw override if tab active?
        if self.tabs.currentWidget() == self.raw_editor:
            self.handler.content = self.raw_editor.toPlainText()

        self.handler.create_backup()
        self.handler.save_config()
        self.update_config_list()
        QMessageBox.information(self, "Saved", "Configuration Saved!")

    def reload_settings(self):
        self.handler.load_config()
        # Refresh widgets
        for key, (widget, getter) in self.widget_map.items():
            path, k = key.split(":")
            val = self.handler.get_value(path, k, "")
            if isinstance(widget, QCheckBox): widget.setChecked(val.lower() == "true")
            elif isinstance(widget, QLineEdit): widget.setText(str(val))
            # ... others
        
        self.raw_editor.setPlainText(self.handler.content)
        self.load_outputs_tree()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = NiriWindow()
    win.show()
    sys.exit(app.exec_())
    