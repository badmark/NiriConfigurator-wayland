#!/usr/bin/env python3
import sys
import os
import re
import subprocess
import glob
import shutil
import traceback
from pathlib import Path
from datetime import datetime

try:
    from PyQt5.QtWidgets import (
        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
        QTabWidget, QLabel, QLineEdit, QComboBox, QCheckBox, QPushButton, 
        QTextEdit, QPlainTextEdit, QSplitter, QTreeWidget, QTreeWidgetItem, 
        QHeaderView, QFormLayout, QScrollArea, QMessageBox, QFileDialog, 
        QColorDialog, QFrame, QSizePolicy, QAction, QGroupBox, QSpinBox
    )
    from PyQt5.QtCore import Qt, QRect, QSize, pyqtSignal, pyqtSlot
    from PyQt5.QtGui import QColor, QPainter, QTextFormat, QPalette, QFont
except ImportError:
    print("Error: PyQt5 not found. Please install it (e.g., 'sudo pacman -S python-pyqt5' or 'pip install PyQt5').")
    sys.exit(1)

# ==============================================================================
# CONSTANTS & DEFAULTS
# ==============================================================================
NIRI_ACTIONS = [
    "quit", "close-window", "power-off-monitors", "show-hotkey-overlay",
    "focus-window-history-down", "focus-window-history-up",
    "focus-column-left", "focus-column-right", "focus-window-up", "focus-window-down",
    "move-column-left", "move-column-right", "move-window-up", "move-window-down",
    "focus-workspace-down", "focus-workspace-up", 
    "move-column-to-workspace-down", "move-column-to-workspace-up",
    "focus-monitor-left", "focus-monitor-right", "focus-monitor-down", "focus-monitor-up",
    "move-column-to-monitor-left", "move-column-to-monitor-right", 
    "move-column-to-monitor-down", "move-column-to-monitor-up",
    "maximize-column", "fullscreen-window", "center-column", 
    "set-column-width", "switch-preset-column-width",
    "consume-window-into-column", "expel-window-from-column",
    "screenshot", "screenshot-screen", "screenshot-window"
]

DEFAULT_CONFIG = """
// Niri Default Configuration
// Auto-generated by NiCoEd

input {
    keyboard {
        xkb {
            layout "us"
        }
    }
    touchpad {
        tap
        natural-scroll
        dwt
    }
    focus-follows-mouse
}

output "eDP-1" {
    scale 1.0
    transform "normal"
    position x=0 y=0
}

layout {
    gaps 16
    center-focused-column "never"
    default-column-width { proportion 0.5; }

    focus-ring {
        width 4
        active-color "#7fc8ff"
        inactive-color "#505050"
    }

    border {
        off
        width 4
        active-color "#ffc87f"
        inactive-color "#505050"
    }
}

binds {
    Mod+Shift+E { quit; }
    Mod+Q { close-window; }
}
"""

# ==============================================================================
# LOGIC: Config Handler
# ==============================================================================
class NiriConfigHandler:
    def __init__(self):
        self.config_path = self.get_config_path()
        self.content = ""
        self.load_config()

    def get_config_path(self):
        return Path.home() / ".config" / "niri" / "config.kdl"

    def load_config(self, filepath=None):
        target = filepath if filepath else self.config_path
        if target.exists():
            with open(target, "r") as f:
                self.content = f.read()
            return True
        else:
            self.content = DEFAULT_CONFIG
            return False

    def save_config(self):
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, "w") as f:
            f.write(self.content)

    def create_backup(self):
        if not self.config_path.exists(): return None
        base_bak = self.config_path.with_name("config.kdl.bak")
        target_bak = base_bak
        count = 1
        while target_bak.exists():
            target_bak = self.config_path.with_name(f"config.kdl.bak{count}")
            count += 1
        try:
            shutil.copy2(self.config_path, target_bak)
            return target_bak.name
        except Exception as e:
            print(f"Backup failed: {e}")
            return None

    def list_configs(self):
        configs = []
        if self.config_path.exists():
            timestamp = datetime.fromtimestamp(self.config_path.stat().st_mtime).strftime("%H:%M:%S")
            configs.append((f"Current Config ({timestamp})", str(self.config_path)))
        parent = self.config_path.parent
        if parent.exists():
            backups = list(parent.glob("config.kdl.bak*"))
            backups.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            for bak in backups:
                ts = datetime.fromtimestamp(bak.stat().st_mtime).strftime("%Y-%m-%d %H:%M")
                configs.append((f"{bak.name} ({ts})", str(bak)))
        return configs

    def extract_block_content(self, text, block_name):
        pattern = re.compile(rf"\b{block_name}\b.*\{{")
        match = pattern.search(text)
        if not match: return None
        start_idx = match.start()
        open_brace_idx = match.end() - 1
        brace_count = 1
        i = open_brace_idx + 1
        while i < len(text) and brace_count > 0:
            if text[i] == '{': brace_count += 1
            elif text[i] == '}': brace_count -= 1
            i += 1
        if brace_count == 0: return (start_idx, i, text[open_brace_idx+1:i-1])
        return None

    def update_block(self, block_name, new_inner_content):
        result = self.extract_block_content(self.content, block_name)
        if result:
            start_idx, end_idx, _ = result
            brace_pos = self.content.find('{', start_idx)
            header = self.content[start_idx:brace_pos+1]
            self.content = self.content[:start_idx] + f"{header}\n{new_inner_content}\n}}" + self.content[end_idx:]
        else:
            self.content += f"\n{block_name} {{\n{new_inner_content}\n}}\n"

    def extract_repeated_blocks(self, block_name):
        blocks = []
        pattern = re.compile(rf'{block_name}\s+"([^"]+)"\s*\{{')
        text = self.content; search_start = 0
        while True:
            match = pattern.search(text, search_start)
            if not match: break
            name = match.group(1); brace_open_idx = match.end() - 1; brace_count = 1; i = brace_open_idx + 1
            while i < len(text) and brace_count > 0:
                if text[i] == '{': brace_count += 1
                elif text[i] == '}': brace_count -= 1
                i += 1
            if brace_count == 0:
                end_idx = i; inner = text[brace_open_idx+1 : end_idx-1]
                blocks.append({'name': name, 'content': inner, 'span': (match.start(), end_idx)})
                search_start = end_idx
            else: break
        return blocks

    def replace_repeated_blocks(self, block_name, new_blocks_str):
        current_blocks = self.extract_repeated_blocks(block_name)
        current_blocks.sort(key=lambda x: x['span'][0], reverse=True)
        for b in current_blocks: self.content = self.content[:b['span'][0]] + self.content[b['span'][1]:]
        self.content = self.content.rstrip() + "\n\n" + new_blocks_str

    def extract_rules(self, rule_type):
        rules = []
        pattern = re.compile(rf'\n\s*{rule_type}\s*\{{')
        text = self.content; search_start = 0
        while True:
            match = pattern.search(text, search_start)
            if not match: break
            brace_open_idx = match.end() - 1; brace_count = 1; i = brace_open_idx + 1
            while i < len(text) and brace_count > 0:
                if text[i] == '{': brace_count += 1
                elif text[i] == '}': brace_count -= 1
                i += 1
            if brace_count == 0:
                end_idx = i; inner = text[brace_open_idx+1 : end_idx-1]
                rules.append({'content': inner, 'span': (match.start(), end_idx)})
                search_start = end_idx
            else: break
        return rules

    def replace_rules(self, rule_type, new_blocks_str):
        current_rules = self.extract_rules(rule_type)
        current_rules.sort(key=lambda x: x['span'][0], reverse=True)
        for r in current_rules: self.content = self.content[:r['span'][0]] + self.content[r['span'][1]:]
        self.content = self.content.rstrip() + "\n\n" + new_blocks_str

    def extract_all_outputs(self): return self.extract_repeated_blocks("output")
    def replace_outputs_section(self, s): self.replace_repeated_blocks("output", s)
    def extract_named_workspaces(self): return self.extract_repeated_blocks("workspace")
    def replace_named_workspaces_section(self, s): self.replace_repeated_blocks("workspace", s)
    def extract_window_rules(self): return self.extract_rules("window-rule")
    def replace_window_rules_section(self, s): self.replace_rules("window-rule", s)
    def extract_layer_rules(self): return self.extract_rules("layer-rule")
    def replace_layer_rules_section(self, s): self.replace_rules("layer-rule", s)
    
    def extract_spawn_actions(self):
        actions = []
        pattern = re.compile(r'^\s*(spawn-at-startup|spawn-sh-at-startup)\s+(?:\"([^\"]*)\"|([^;\s]+))', re.MULTILINE)
        for m in pattern.finditer(self.content):
            actions.append({'type': m.group(1), 'command': m.group(2) or m.group(3)})
        return actions

    def replace_spawn_actions(self, new_actions):
        self.content = re.sub(r'^\s*(spawn-at-startup|spawn-sh-at-startup)\s+.*(\r\n|\r|\n)?', '', self.content, flags=re.MULTILINE)
        new_block = "\n"
        for act in new_actions: new_block += f"    {act['type']} \"{act['command']}\"\n"
        self.content += new_block

    def extract_environment_vars(self):
        vars_list = []
        result = self.extract_block_content(self.content, "environment")
        if not result: return []
        for line in result[2].split('\n'):
            line = line.strip().strip(';')
            if not line or line.startswith("//"): continue
            parts = line.split(maxsplit=1)
            if len(parts) == 2: vars_list.append({'name': parts[0], 'value': parts[1].strip('"')})
        return vars_list

    def replace_environment_section(self, vars_list):
        inner = ""
        for v in vars_list: inner += f"    {v['name']} \"{v['value']}\"\n"
        self.update_block("environment", inner)
        
    def extract_switch_events(self):
        switches = []
        # Usually inside 'input' block -> 'switch-events' block
        # We try to extract input, then switch-events
        in_res = self.extract_block_content(self.content, "input")
        if in_res:
            sw_res = self.extract_block_content(in_res[2], "switch-events")
            if sw_res:
                lines = sw_res[2].split('\n')
                for line in lines:
                    line = line.strip()
                    if '{' in line and not line.startswith("//"):
                        evt, act = line.split('{', 1)
                        switches.append({'event': evt.strip(), 'action': act.strip(' }')})
        return switches

    def replace_switch_events(self, switches_data):
        inner = ""
        for s in switches_data:
            inner += f"        {s['event']} {{ {s['action']} }}\n"
        
        # We need to construct the full input structure properly if updating
        # For simplicity, we assume 'input' block exists, and we want to update/add 'switch-events' inside it.
        # This is complex with regex. A safe approach is:
        # 1. Extract 'input' block.
        # 2. Extract 'switch-events' from that.
        # 3. Replace 'switch-events' content or append it.
        # 4. Replace 'input' block in main content.
        
        in_res = self.extract_block_content(self.content, "input")
        if in_res:
            s, e, in_content = in_res
            sw_res = self.extract_block_content(in_content, "switch-events")
            
            new_sw_block = f"    switch-events {{\n{inner}    }}\n"
            
            if sw_res:
                ss, se, _ = sw_res
                # Reconstruct input block with new switch block
                new_in_content = in_content[:ss] + f"switch-events {{\n{inner}    }}" + in_content[se+1:] # +1 for brace
            else:
                # Append to input
                new_in_content = in_content + new_sw_block
                
            # Update main content
            brace_pos = self.content.find('{', s)
            header = self.content[s:brace_pos+1]
            self.content = self.content[:s] + f"{header}{new_in_content}}}" + self.content[e:]

    def extract_includes(self):
        return [m.group(1) for m in re.finditer(r'^\s*include\s+"([^"]+)"', self.content, re.MULTILINE)]

    def replace_includes(self, new_includes):
        self.content = re.sub(r'^\s*include\s+"[^"]+".*(\r\n|\r|\n)?', '', self.content, flags=re.MULTILINE)
        block = ""
        for inc in new_includes: block += f'include "{inc}"\n'
        self.content = block + "\n" + self.content.strip()

    def get_value(self, path, key, default):
        current_text = self.content
        if path:
            blocks = path.split(".")
            for b in blocks:
                result = self.extract_block_content(current_text, b)
                if result: _, _, inner = result; current_text = inner
                else: return default
        match = re.search(rf"\b{key}\s+(?:\"([^\"]*)\"|([^;\s]+))", current_text)
        if match: return match.group(1) if match.group(1) is not None else match.group(2)
        if default in ["true", "false"]: return "true" if re.search(rf"\b{key}[;\s]", current_text) else "false"
        return default

    def set_value(self, path, key, value, is_string=False):
        self.content = self._update_recursive(self.content, path.split(".") if path else [], key, value, is_string)

    def _update_recursive(self, text, block_path, key, value, is_string):
        if not block_path:
            val_str = f'"{value}"' if is_string else str(value)
            if value.lower() == "true" and not is_string:
                if not re.search(rf"\b{key}[;\s]", text): return text.rstrip() + f"\n    {key};\n"
                return text 
            elif value.lower() == "false" and not is_string:
                return re.sub(rf"\s*{key}[;\s]", "", text)
            line = f"    {key} {val_str};\n"
            if re.search(rf"(\b{key}\s+)[^;]+;", text): return re.sub(rf"(\b{key}\s+)[^;]+;", rf"\1{val_str};", text)
            else: return text.rstrip() + "\n" + line

        current = block_path[0]
        result = self.extract_block_content(text, current)
        if result:
            s, e, inner = result
            new_inner = self._update_recursive(inner, block_path[1:], key, value, is_string)
            header = text[s : text.find('{', s)+1]
            return text[:s] + f"{header}{new_inner}}}" + text[e:]
        else:
            child = self._create_new_block(block_path[1:], key, value, is_string)
            return text + f"\n{current} {{\n{child}}}\n"

    def _create_new_block(self, block_path, key, value, is_string):
        if not block_path:
            val_str = f'"{value}"' if is_string else str(value)
            if value.lower() == "true": return f"    {key};\n"
            if value.lower() == "false": return ""
            return f"    {key} {val_str};\n"
        current = block_path[0]
        inner = self._create_new_block(block_path[1:], key, value, is_string)
        return f"    {current} {{\n{inner}    }}\n"

# ==============================================================================
# Hardware Info
# ==============================================================================
class SystemInfo:
    @staticmethod
    def get_connected_outputs():
        outputs = []
        try:
            res = subprocess.run(['niri', 'msg', '-j', 'outputs'], capture_output=True, text=True, timeout=1)
            if res.returncode == 0:
                import json; data = json.loads(res.stdout)
                for name in data.keys(): outputs.append(name)
        except: pass
        return outputs if outputs else ["eDP-1", "HDMI-A-1"]
    
    @staticmethod
    def get_drm_devices(): return glob.glob("/dev/dri/card*") or ["/dev/dri/card0"]

    @staticmethod
    def get_installed_cursor_themes():
        themes = set()
        for p in [Path.home()/".icons", Path.home()/".local/share/icons", Path("/usr/share/icons")]:
            if p.exists():
                for i in p.iterdir():
                    if (i/"cursors").exists() or (i/"index.theme").exists(): themes.add(i.name)
        return sorted(list(themes)) if themes else ["Adwaita", "default"]

# ==============================================================================
# CUSTOM WIDGETS
# ==============================================================================
class LineNumberArea(QWidget):
    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor
    def sizeHint(self): return QSize(self.editor.lineNumberAreaWidth(), 0)
    def paintEvent(self, event): self.editor.lineNumberAreaPaintEvent(event)

class CodeEditor(QPlainTextEdit):
    def __init__(self):
        super().__init__()
        self.lineNumberArea = LineNumberArea(self)
        self.blockCountChanged.connect(self.updateLineNumberAreaWidth)
        self.updateRequest.connect(self.updateLineNumberArea)
        self.cursorPositionChanged.connect(self.highlightCurrentLine)
        self.updateLineNumberAreaWidth(0)
        self.setFont(QFont("Monospace"))
        self.is_dark = False

    def lineNumberAreaWidth(self):
        digits = 1; max_val = max(1, self.blockCount())
        while max_val >= 10: max_val //= 10; digits += 1
        return 3 + self.fontMetrics().width('9') * digits

    def updateLineNumberAreaWidth(self, _):
        self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

    def updateLineNumberArea(self, rect, dy):
        if dy: self.lineNumberArea.scroll(0, dy)
        else: self.lineNumberArea.update(0, rect.y(), self.lineNumberArea.width(), rect.height())
        if rect.contains(self.viewport().rect()): self.updateLineNumberAreaWidth(0)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.lineNumberArea.setGeometry(QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height()))

    def lineNumberAreaPaintEvent(self, event):
        painter = QPainter(self.lineNumberArea)
        painter.fillRect(event.rect(), Qt.lightGray if not self.is_dark else QColor("#2d2d2d"))
        block = self.firstVisibleBlock()
        blockNumber = block.blockNumber()
        top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
        bottom = top + int(self.blockBoundingGeometry(block).height())
        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(blockNumber + 1)
                painter.setPen(Qt.black if not self.is_dark else Qt.lightGray)
                painter.drawText(0, top, self.lineNumberArea.width(), self.fontMetrics().height(), Qt.AlignRight, number)
            block = block.next(); top = bottom; bottom = top + int(self.blockBoundingGeometry(block).height()); blockNumber += 1

    def highlightCurrentLine(self):
        extraSelections = []
        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            lineColor = QColor(Qt.yellow).lighter(160) if not self.is_dark else QColor("#3d3d3d")
            selection.format.setBackground(lineColor)
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor(); selection.cursor.clearSelection()
            extraSelections.append(selection)
        self.setExtraSelections(extraSelections)
    
    def set_theme(self, is_dark):
        self.is_dark = is_dark
        p = self.palette()
        p.setColor(QPalette.Base, QColor("#1e1e1e") if is_dark else QColor("#ffffff"))
        p.setColor(QPalette.Text, QColor("#ffffff") if is_dark else QColor("#000000"))
        self.setPalette(p)
        self.highlightCurrentLine()
        self.update()

# ==============================================================================
# GUI: Main Window (PyQt5)
# ==============================================================================
class NiriWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("NiCoEd - Niri Config Editor")
        self.resize(1200, 850)
        
        self.handler = NiriConfigHandler()
        self.widget_map = {}
        self.outputs_data = []
        self.binds_data = []
        self.layer_rules_data = []
        self.rules_data = []
        self.spawn_data = []
        self.env_data = []
        self.switch_data = []
        
        self.sys_outputs = SystemInfo.get_connected_outputs()
        self.sys_cursors = SystemInfo.get_installed_cursor_themes()
        self.sys_drm = SystemInfo.get_drm_devices()
        
        # Central Layout
        self.central = QWidget(); self.setCentralWidget(self.central)
        self.layout = QVBoxLayout(self.central)
        
        self.tabs = QTabWidget(); self.layout.addWidget(self.tabs)
        
        # Footer
        self.lbl_info = QLabel("Ready.")
        self.layout.addWidget(self.lbl_info)
        
        btn_box = QHBoxLayout()
        self.btn_theme = QPushButton("ðŸŒ— Theme"); self.btn_theme.clicked.connect(self.toggle_theme)
        self.combo_load = QComboBox(); self.combo_load.currentIndexChanged.connect(self.on_config_selected)
        btn_reload = QPushButton("Reload"); btn_reload.clicked.connect(self.reload_settings)
        btn_save = QPushButton("Save All"); btn_save.clicked.connect(self.prompt_save)
        
        btn_box.addWidget(self.btn_theme)
        btn_box.addWidget(QLabel("Load:"))
        btn_box.addWidget(self.combo_load)
        btn_box.addStretch()
        btn_box.addWidget(btn_reload)
        btn_box.addWidget(btn_save)
        self.layout.addLayout(btn_box)
        
        self.init_tabs()
        self.update_config_list()
        self.is_dark = False; self.apply_theme()

    def init_tabs(self):
        self.create_input_tab()
        self.create_outputs_tab()
        self.create_layout_tab()
        self.create_workspaces_tab()
        self.create_cursor_tab()
        self.create_window_rules_tab()
        self.create_layer_rules_tab()
        self.create_animations_tab()
        self.create_misc_tab()
        self.create_environment_tab()
        self.create_debug_tab()
        self.create_binds_tab()
        self.create_switches_tab()
        self.create_gestures_tab()
        self.create_recent_windows_tab()
        self.create_includes_tab()
        self.create_raw_tab()

    def add_tab(self, widget, title):
        self.tabs.addTab(widget, title)

    def create_form_row(self, layout, label, path, key, default, is_bool=False, options=None, is_color=False, is_file=False):
        lbl = QLabel(label)
        val = self.handler.get_value(path, key, default)
        
        if is_bool:
            w = QCheckBox(); w.setChecked(val.lower() == "true")
            get = lambda: "true" if w.isChecked() else "false"
        elif options:
            w = QComboBox(); w.addItems(options); w.setCurrentText(val)
            get = lambda: w.currentText()
        else:
            w = QLineEdit(str(val))
            get = lambda: w.text()
            
        box = QHBoxLayout(); box.setContentsMargins(0,0,0,0); box.addWidget(w)
        if is_color:
            b = QPushButton("ðŸŽ¨"); b.clicked.connect(lambda: self.pick_color(w)); box.addWidget(b)
        if is_file:
            b = QPushButton("ðŸ“‚"); b.clicked.connect(lambda: self.pick_file(w)); box.addWidget(b)
            
        container = QWidget(); container.setLayout(box)
        layout.addRow(lbl, container)
        self.widget_map[f"{path}:{key}"] = (w, get)

    def pick_color(self, w):
        c = QColorDialog.getColor(); 
        if c.isValid(): w.setText(c.name())
    def pick_file(self, w):
        f, _ = QFileDialog.getOpenFileName(self, "Select"); 
        if f: w.setText(f)

    # --- TABS ---
    def create_input_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Warn Keymap", "input", "warn-no-keymap", "false", is_bool=True)
        self.create_form_row(l, "Power Key", "input", "power-key-action", "power-off", options=["power-off", "suspend", "interactive"])
        self.create_form_row(l, "Focus Mouse", "input", "focus-follows-mouse", "false", is_bool=True)
        
        l.addRow(QLabel("<b>Keyboard</b>"))
        self.create_form_row(l, "Layout", "input.keyboard.xkb", "layout", "us")
        self.create_form_row(l, "Repeat Delay", "input.keyboard", "repeat-delay", "600")
        self.create_form_row(l, "Repeat Rate", "input.keyboard", "repeat-rate", "25")
        
        l.addRow(QLabel("<b>Touchpad</b>"))
        self.create_form_row(l, "Tap Click", "input.touchpad", "tap", "false", is_bool=True)
        self.create_form_row(l, "Natural Scroll", "input.touchpad", "natural-scroll", "false", is_bool=True)
        self.create_form_row(l, "DWT", "input.touchpad", "dwt", "true", is_bool=True)
        self.create_form_row(l, "Click Method", "input.touchpad", "click-method", "button-areas", options=["button-areas", "clickfinger", "none"])
        
        self.add_tab(w, "Input")

    def create_outputs_tab(self):
        split = QSplitter(); self.out_tree = QTreeWidget(); self.out_tree.setHeaderLabels(["Output"])
        split.addWidget(self.out_tree)
        
        w = QWidget(); l = QFormLayout(w)
        self.out_mode = QComboBox(); self.out_mode.setEditable(True)
        self.out_scale = QLineEdit()
        self.out_trans = QComboBox(); self.out_trans.addItems(["normal", "90", "180", "270", "flipped"])
        self.out_pos = QLineEdit()
        
        l.addRow("Mode", self.out_mode); l.addRow("Scale", self.out_scale)
        l.addRow("Transform", self.out_trans); l.addRow("Position", self.out_pos)
        btn = QPushButton("Update / Add"); btn.clicked.connect(self.save_output_to_mem); l.addRow(btn)
        
        # Add Input
        self.new_out = QComboBox(); self.new_out.addItems(self.sys_outputs); self.new_out.setEditable(True)
        btn_add = QPushButton("Add New"); btn_add.clicked.connect(self.add_new_output); l.addRow(self.new_out, btn_add)
        btn_del = QPushButton("Delete Selected"); btn_del.clicked.connect(self.del_output); l.addRow(btn_del)
        
        split.addWidget(w); self.add_tab(split, "Outputs")
        self.out_tree.itemSelectionChanged.connect(self.on_out_select)
        self.reload_outputs()

    def reload_outputs(self):
        self.out_tree.clear()
        self.outputs_data = self.handler.extract_all_outputs()
        for o in self.outputs_data: QTreeWidgetItem(self.out_tree, [o['name']])

    def on_out_select(self):
        item = self.out_tree.currentItem()
        if not item: return
        name = item.text(0)
        data = next((x for x in self.outputs_data if x['name'] == name), None)
        if data:
            c = data['content']
            # Simple parse
            m = re.search(r'mode\s+"([^"]+)"', c); self.out_mode.setCurrentText(m.group(1) if m else "")
            s = re.search(r'scale\s+([\d\.]+)', c); self.out_scale.setText(s.group(1) if s else "1.0")
            t = re.search(r'transform\s+"([^"]+)"', c); self.out_trans.setCurrentText(t.group(1) if t else "normal")
            p = re.search(r'position\s+(.+)', c); self.out_pos.setText(p.group(1) if p else "")

    def save_output_to_mem(self):
        item = self.out_tree.currentItem()
        if not item: return
        name = item.text(0)
        c = f'    mode "{self.out_mode.currentText()}"\n    scale {self.out_scale.text()}\n    transform "{self.out_trans.currentText()}"\n'
        if self.out_pos.text(): c += f'    position {self.out_pos.text()}\n'
        
        for o in self.outputs_data:
            if o['name'] == name: o['content'] = c
        QMessageBox.information(self, "Updated", "Output updated in memory.")

    def add_new_output(self):
        name = self.new_out.currentText()
        if name:
            self.outputs_data.append({'name': name, 'content': '', 'span':(0,0)})
            self.reload_outputs()

    def del_output(self):
        item = self.out_tree.currentItem()
        if item:
            name = item.text(0)
            self.outputs_data = [o for o in self.outputs_data if o['name'] != name]
            self.reload_outputs()

    def save_outputs(self):
        block = ""
        for o in self.outputs_data: block += f'output "{o["name"]}" {{\n{o.get("content", "")}}}\n'
        self.handler.replace_outputs_section(block)

    def create_layout_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Gaps", "layout", "gaps", "16")
        self.create_form_row(l, "Border Width", "layout.border", "width", "4")
        self.create_form_row(l, "Active Color", "layout.border", "active-color", "#ff0000", is_color=True)
        self.create_form_row(l, "Focus Color", "layout.focus-ring", "active-color", "#7fc8ff", is_color=True)
        l.addRow(QLabel("<b>Tab Indicator</b>"))
        self.create_form_row(l, "Hide Single", "layout.tab-indicator", "hide-when-single", "false", is_bool=True)
        self.create_form_row(l, "Position", "layout.tab-indicator", "position", "top", options=["top", "bottom"])
        self.add_tab(w, "Layout")

    def create_workspaces_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.ws_tree = QTreeWidget(); self.ws_tree.setHeaderLabels(["Workspace"])
        split.addWidget(self.ws_tree)
        w = QWidget(); l = QFormLayout(w)
        self.ws_name = QLineEdit(); l.addRow("Name", self.ws_name)
        self.ws_out = QComboBox(); self.ws_out.addItems(self.sys_outputs)
        l.addRow("Output", self.ws_out)
        btn_add = QPushButton("Add/Update"); btn_add.clicked.connect(self.save_ws_mem); l.addRow(btn_add)
        btn_del = QPushButton("Delete"); btn_del.clicked.connect(self.del_ws); l.addRow(btn_del)
        split.addWidget(w)
        self.add_tab(split, "Workspaces")
        self.reload_ws()

    def reload_ws(self):
        self.ws_tree.clear()
        self.ws_data = self.handler.extract_named_workspaces()
        for w in self.ws_data: QTreeWidgetItem(self.ws_tree, [w['name']])
    
    def save_ws_mem(self):
        name = self.ws_name.text()
        if not name: return
        c = f'    open-on-output "{self.ws_out.currentText()}"\n'
        
        exists = False
        for w in self.ws_data:
            if w['name'] == name: w['content'] = c; exists = True
        if not exists: self.ws_data.append({'name': name, 'content': c, 'span':(0,0)})
        self.reload_ws()

    def del_ws(self):
        item = self.ws_tree.currentItem()
        if item:
            self.ws_data = [w for w in self.ws_data if w['name'] != item.text(0)]
            self.reload_ws()

    def save_ws(self):
        block = ""
        for w in self.ws_data: block += f'workspace "{w["name"]}" {{\n{w.get("content", "")}}}\n'
        self.handler.replace_named_workspaces_section(block)

    def create_cursor_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Theme", "", "xcursor-theme", "", options=self.sys_cursors)
        self.create_form_row(l, "Size", "", "xcursor-size", "24")
        self.add_tab(w, "Cursor")

    def create_binds_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.bind_tree = QTreeWidget(); self.bind_tree.setHeaderLabels(["Key", "Action"])
        self.bind_tree.itemSelectionChanged.connect(self.on_bind_select_ui)
        split.addWidget(self.bind_tree)
        
        w = QWidget(); l = QVBoxLayout(w)
        
        gb = QGroupBox("Add/Edit Bind"); gl = QFormLayout(gb)
        self.bn_mod = QCheckBox("Mod"); self.bn_mod.setChecked(True)
        self.bn_s = QCheckBox("Shift"); self.bn_c = QCheckBox("Ctrl"); self.bn_a = QCheckBox("Alt")
        mod_box = QHBoxLayout(); mod_box.addWidget(self.bn_mod); mod_box.addWidget(self.bn_s); mod_box.addWidget(self.bn_c); mod_box.addWidget(self.bn_a)
        gl.addRow("Modifiers", mod_box)
        
        self.bn_key = QLineEdit(); gl.addRow("Key", self.bn_key)
        self.bn_act = QComboBox(); self.bn_act.addItems(NIRI_ACTIONS); self.bn_act.setEditable(True)
        gl.addRow("Action", self.bn_act)
        self.bn_spawn = QLineEdit(); gl.addRow("Spawn Cmd", self.bn_spawn)
        
        btn = QPushButton("Add/Update"); btn.clicked.connect(self.add_bind); gl.addRow(btn)
        l.addWidget(gb)
        btn_del = QPushButton("Delete Selected"); btn_del.clicked.connect(self.del_bind); l.addWidget(btn_del)
        l.addStretch()
        
        split.addWidget(w)
        self.add_tab(split, "Binds")
        self.reload_binds()

    def reload_binds(self):
        self.bind_tree.clear()
        res = self.handler.extract_block_content(self.handler.content, "binds")
        self.bind_data = []
        if res:
            for line in res[2].split('\n'):
                line = line.strip()
                if '{' in line:
                    k, a = line.split('{', 1)
                    k, a = k.strip(), a.strip(' }')
                    self.bind_data.append((k, a))
                    QTreeWidgetItem(self.bind_tree, [k, a])

    def on_bind_select_ui(self):
        item = self.bind_tree.currentItem()
        if not item: return
        key = item.text(0)
        action = item.text(1)
        
        # Reset modifiers
        self.bn_mod.setChecked(False); self.bn_s.setChecked(False); self.bn_c.setChecked(False); self.bn_a.setChecked(False)
        
        parts = key.split("+")
        final_k = ""
        for p in parts:
            if p == "Mod": self.bn_mod.setChecked(True)
            elif p == "Shift": self.bn_s.setChecked(True)
            elif p == "Ctrl": self.bn_c.setChecked(True)
            elif p == "Alt": self.bn_a.setChecked(True)
            else: final_k = p
        
        self.bn_key.setText(final_k)
        
        if action.startswith("spawn"):
            self.bn_act.setCurrentText("")
            # Extract spawn cmd
            m = re.search(r'spawn\s+"([^"]+)"', action)
            if m: self.bn_spawn.setText(m.group(1))
            else: self.bn_spawn.setText(action.replace("spawn ", "").replace(";", "").strip('"'))
        else:
            self.bn_act.setCurrentText(action.replace(";", ""))
            self.bn_spawn.setText("")

    def add_bind(self):
        mods = []
        if self.bn_mod.isChecked(): mods.append("Mod")
        if self.bn_s.isChecked(): mods.append("Shift")
        if self.bn_c.isChecked(): mods.append("Ctrl")
        if self.bn_a.isChecked(): mods.append("Alt")
        k = "+".join(mods + [self.bn_key.text()])
        
        act = self.bn_act.currentText()
        if self.bn_spawn.text(): act = f'spawn "{self.bn_spawn.text()}"'
        if not act.endswith(';'): act += ";"
        
        # Check if updating
        exists = False
        for i, (bk, ba) in enumerate(self.bind_data):
            if bk == k:
                self.bind_data[i] = (k, act)
                exists = True
                break
        if not exists:
            self.bind_data.append((k, act))
            
        self.reload_binds_ui()

    def reload_binds_ui(self):
        self.bind_tree.clear()
        for k, a in self.bind_data: QTreeWidgetItem(self.bind_tree, [k, a])

    def del_bind(self):
        item = self.bind_tree.currentItem()
        if item:
            k = item.text(0)
            self.bind_data = [b for b in self.bind_data if b[0] != k]
            self.reload_binds_ui()

    def save_binds(self):
        block = ""
        for k, a in self.bind_data: block += f"    {k} {{ {a} }}\n"
        self.handler.update_block("binds", block)

    def create_misc_tab(self):
        w = QWidget(); l = QFormLayout(w)
        
        # Screenshot Section
        gb_scr = QGroupBox("Screenshot Settings")
        l_scr = QFormLayout(gb_scr)
        
        self.ss_dir = QLineEdit()
        btn_browse = QPushButton("ðŸ“‚")
        btn_browse.clicked.connect(self.browse_ss_dir)
        h_dir = QHBoxLayout(); h_dir.addWidget(self.ss_dir); h_dir.addWidget(btn_browse)
        l_scr.addRow("Folder", h_dir)
        
        self.ss_file = QLineEdit()
        self.ss_vars = QComboBox()
        self.ss_vars.addItems(["Insert Variable...", "%Y (Year)", "%m (Month)", "%d (Day)", "%H (Hour)", "%M (Min)", "%S (Sec)"])
        self.ss_vars.activated.connect(self.insert_ss_var)
        l_scr.addRow("Filename", self.ss_file)
        l_scr.addRow("", self.ss_vars)
        
        l.addRow(gb_scr)

        self.create_form_row(l, "No CSD", "", "prefer-no-csd", "false", is_bool=True)
        
        # Spawns
        self.spawn_tree = QTreeWidget(); self.spawn_tree.setHeaderLabels(["Type", "Command"])
        self.spawn_tree.itemSelectionChanged.connect(self.on_spawn_select_ui)
        l.addRow("Startups:", self.spawn_tree)
        
        self.sp_type = QComboBox(); self.sp_type.addItems(["spawn-at-startup", "spawn-sh-at-startup"])
        self.sp_cmd = QLineEdit()
        l.addRow(self.sp_type, self.sp_cmd)
        
        btn_box = QHBoxLayout()
        btn_add = QPushButton("Add"); btn_add.clicked.connect(self.add_spawn)
        btn_upd = QPushButton("Update"); btn_upd.clicked.connect(self.update_spawn)
        btn_del = QPushButton("Delete"); btn_del.clicked.connect(self.del_spawn)
        btn_box.addWidget(btn_add); btn_box.addWidget(btn_upd); btn_box.addWidget(btn_del)
        l.addRow(btn_box)
        
        self.add_tab(w, "Misc")
        self.reload_spawns()
        self.reload_screenshot_ui()

    def browse_ss_dir(self):
        d = QFileDialog.getExistingDirectory(self, "Select Screenshot Directory")
        if d: self.ss_dir.setText(d)

    def insert_ss_var(self, index):
        if index > 0:
            var = self.ss_vars.currentText().split(" ")[0]
            self.ss_file.insert(var)
            self.ss_vars.setCurrentIndex(0)

    def reload_screenshot_ui(self):
        full = self.handler.get_value("", "screenshot-path", "")
        if full:
            full = full.strip('"')
            d, f = os.path.split(full)
            self.ss_dir.setText(d)
            self.ss_file.setText(f)

    def save_screenshot_to_handler(self):
        if self.ss_dir.text() and self.ss_file.text():
            full = os.path.join(self.ss_dir.text(), self.ss_file.text())
            self.handler.set_value("", "screenshot-path", full, True)

    def reload_spawns(self):
        self.spawn_tree.clear()
        self.spawn_data = self.handler.extract_spawn_actions()
        for s in self.spawn_data: QTreeWidgetItem(self.spawn_tree, [s['type'], s['command']])

    def on_spawn_select_ui(self):
        item = self.spawn_tree.currentItem()
        if not item: return
        self.sp_type.setCurrentText(item.text(0))
        self.sp_cmd.setText(item.text(1))

    def add_spawn(self):
        self.spawn_data.append({'type': self.sp_type.currentText(), 'command': self.sp_cmd.text()})
        self.reload_spawns()

    def update_spawn(self):
        item = self.spawn_tree.currentItem()
        if not item: return
        idx = self.spawn_tree.indexOfTopLevelItem(item)
        self.spawn_data[idx] = {'type': self.sp_type.currentText(), 'command': self.sp_cmd.text()}
        self.reload_spawns()
        
    def del_spawn(self):
        item = self.spawn_tree.currentItem()
        if item:
            idx = self.spawn_tree.indexOfTopLevelItem(item)
            del self.spawn_data[idx]
            self.reload_spawns()
            
    def save_spawns(self):
        self.handler.replace_spawn_actions(self.spawn_data)

    def create_environment_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.env_tree = QTreeWidget(); self.env_tree.setHeaderLabels(["Var", "Val"])
        split.addWidget(self.env_tree)
        w = QWidget(); l = QFormLayout(w)
        self.en_k = QLineEdit(); self.en_v = QLineEdit()
        l.addRow("Name", self.en_k); l.addRow("Value", self.en_v)
        btn = QPushButton("Add"); btn.clicked.connect(self.add_env); l.addRow(btn)
        btn_d = QPushButton("Delete"); btn_d.clicked.connect(self.del_env); l.addRow(btn_d)
        split.addWidget(w)
        self.add_tab(split, "Environment")
        self.reload_env()

    def reload_env(self):
        self.env_tree.clear()
        self.env_data = self.handler.extract_environment_vars()
        for e in self.env_data: QTreeWidgetItem(self.env_tree, [e['name'], e['value']])
    
    def add_env(self):
        self.env_data.append({'name': self.en_k.text(), 'value': self.en_v.text()})
        self.reload_env()
    def del_env(self):
        item = self.env_tree.currentItem()
        if item:
            self.env_data = [e for e in self.env_data if e['name'] != item.text(0)]
            self.reload_env()
    def save_env(self):
        self.handler.replace_environment_section(self.env_data)

    def create_switches_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.switch_tree = QTreeWidget(); self.switch_tree.setHeaderLabels(["Event", "Action"])
        split.addWidget(self.switch_tree)
        
        w = QWidget(); l = QFormLayout(w)
        self.sw_evt = QComboBox(); self.sw_evt.addItems(["lid-close", "lid-open", "tablet-mode-on", "tablet-mode-off"])
        self.sw_act = QComboBox(); self.sw_act.addItems(NIRI_ACTIONS); self.sw_act.setEditable(True)
        l.addRow("Event", self.sw_evt)
        l.addRow("Action", self.sw_act)
        
        btn = QPushButton("Add/Update"); btn.clicked.connect(self.add_switch); l.addRow(btn)
        btn_d = QPushButton("Delete"); btn_d.clicked.connect(self.del_switch); l.addRow(btn_d)
        
        split.addWidget(w)
        self.add_tab(split, "Switches")
        self.reload_switches()

    def reload_switches(self):
        self.switch_tree.clear()
        self.switch_data = self.handler.extract_switch_events()
        for s in self.switch_data:
            QTreeWidgetItem(self.switch_tree, [s['event'], s['action']])

    def add_switch(self):
        self.switch_data.append({'event': self.sw_evt.currentText(), 'action': self.sw_act.currentText()})
        self.reload_switches()

    def del_switch(self):
        item = self.switch_tree.currentItem()
        if item:
            self.switch_data = [s for s in self.switch_data if s['event'] != item.text(0)]
            self.reload_switches()

    def save_switches(self):
        self.handler.replace_switch_events(self.switch_data)

    def create_gestures_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Workspace Back/Forth", "input", "workspace-auto-back-and-forth", "false", is_bool=True)
        self.create_form_row(l, "Drag Lock", "input.touchpad", "drag-lock", "false", is_bool=True)
        l.addRow(QLabel("<i>Note: Most gestures are configured via specific key/touchpad bindings in the Binds tab.</i>"))
        self.add_tab(w, "Gestures")

    def create_recent_windows_tab(self):
        w = QWidget(); l = QVBoxLayout(w)
        l.addWidget(QLabel("<b>Helper: Add Window History Binds</b>"))
        
        btn1 = QPushButton("Add 'Mod+[' -> focus-window-history-down")
        btn1.clicked.connect(lambda: self.quick_add_bind("Mod+BracketLeft", "focus-window-history-down"))
        l.addWidget(btn1)
        
        btn2 = QPushButton("Add 'Mod+]' -> focus-window-history-up")
        btn2.clicked.connect(lambda: self.quick_add_bind("Mod+BracketRight", "focus-window-history-up"))
        l.addWidget(btn2)
        l.addStretch()
        self.add_tab(w, "Recent")

    def quick_add_bind(self, k, a):
        # We modify the bind data directly then refresh
        self.bind_data.append((k, a))
        self.reload_binds_ui() # Update Binds tab UI if visible
        QMessageBox.information(self, "Added", f"Added bind: {k} -> {a}")

    def create_includes_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.inc_tree = QTreeWidget(); self.inc_tree.setHeaderLabels(["Path"])
        split.addWidget(self.inc_tree)
        w = QWidget(); l = QHBoxLayout(w)
        self.inc_path = QLineEdit()
        btn = QPushButton("Add"); btn.clicked.connect(self.add_inc)
        btn_d = QPushButton("Delete"); btn_d.clicked.connect(self.del_inc)
        l.addWidget(self.inc_path); l.addWidget(btn); l.addWidget(btn_d)
        
        container = QWidget(); v = QVBoxLayout(container)
        v.addWidget(split); v.addWidget(w)
        self.add_tab(container, "Includes")
        self.reload_includes()

    def reload_includes(self):
        self.inc_tree.clear()
        self.inc_data = self.handler.extract_includes()
        for i in self.inc_data: QTreeWidgetItem(self.inc_tree, [i])
    
    def add_inc(self):
        if self.inc_path.text():
            self.inc_data.append(self.inc_path.text())
            self.reload_includes()
            
    def del_inc(self):
        item = self.inc_tree.currentItem()
        if item:
            self.inc_data.remove(item.text(0))
            self.reload_includes()
            
    def save_includes(self):
        self.handler.replace_includes(self.inc_data)

    def create_layer_rules_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.layer_rule_tree = QTreeWidget()
        self.layer_rule_tree.setHeaderLabels(["Rule Matcher"])
        split.addWidget(self.layer_rule_tree)
        
        w = QWidget(); l = QFormLayout(w)
        
        gb_match = QGroupBox("Match Criteria")
        lm = QFormLayout(gb_match)
        self.lr_namespace = QLineEdit()
        self.lr_id = QLineEdit()
        lm.addRow("Namespace (Regex)", self.lr_namespace)
        lm.addRow("ID (Regex)", self.lr_id)
        l.addRow(gb_match)
        
        gb_props = QGroupBox("Properties")
        lp = QFormLayout(gb_props)
        self.lr_block_out = QComboBox()
        self.lr_block_out.addItems(["", "screencast"])
        self.lr_corner = QLineEdit()
        self.lr_opacity = QLineEdit()
        
        lp.addRow("Block Out From", self.lr_block_out)
        lp.addRow("Corner Radius", self.lr_corner)
        lp.addRow("Opacity", self.lr_opacity)
        l.addRow(gb_props)
        
        btn_update = QPushButton("Update / Add")
        btn_update.clicked.connect(self.save_layer_rule_mem)
        l.addRow(btn_update)
        
        btn_del = QPushButton("Delete Selected")
        btn_del.clicked.connect(self.del_layer_rule)
        l.addRow(btn_del)
        
        split.addWidget(w)
        self.add_tab(split, "Layers")
        
        self.layer_rule_tree.itemSelectionChanged.connect(self.on_layer_rule_select)
        self.reload_layer_rules()

    def reload_layer_rules(self):
        self.layer_rule_tree.clear()
        self.layer_rules_data = [] 
        
        raw_rules = self.handler.extract_layer_rules()
        for r in raw_rules:
            c = r['content']
            data = {'namespace': '', 'id': '', 'block_out': '', 'corner': '', 'opacity': ''}
            
            # Parsing logic
            m_match = re.search(r'match\s+(.*)', c)
            if m_match:
                match_str = m_match.group(1)
                mn = re.search(r'namespace="([^"]+)"', match_str)
                if mn: data['namespace'] = mn.group(1)
                mi = re.search(r'id="([^"]+)"', match_str)
                if mi: data['id'] = mi.group(1)
            
            mb = re.search(r'block-out-from\s+"([^"]+)"', c)
            if mb: data['block_out'] = mb.group(1)
            
            mc = re.search(r'geometry-corner-radius\s+([\d\.]+)', c)
            if mc: data['corner'] = mc.group(1)
            
            mo = re.search(r'opacity\s+([\d\.]+)', c)
            if mo: data['opacity'] = mo.group(1)
            
            self.layer_rules_data.append(data)
            
            label = "Rule"
            if data['namespace']: label += f" ns='{data['namespace']}'"
            if data['id']: label += f" id='{data['id']}'"
            QTreeWidgetItem(self.layer_rule_tree, [label])

    def on_layer_rule_select(self):
        item = self.layer_rule_tree.currentItem()
        if not item: return
        idx = self.layer_rule_tree.indexOfTopLevelItem(item)
        if idx < 0 or idx >= len(self.layer_rules_data): return
        
        d = self.layer_rules_data[idx]
        self.lr_namespace.setText(d['namespace'])
        self.lr_id.setText(d['id'])
        self.lr_block_out.setCurrentText(d['block_out'])
        self.lr_corner.setText(d['corner'])
        self.lr_opacity.setText(d['opacity'])

    def save_layer_rule_mem(self):
        data = {
            'namespace': self.lr_namespace.text(),
            'id': self.lr_id.text(),
            'block_out': self.lr_block_out.currentText(),
            'corner': self.lr_corner.text(),
            'opacity': self.lr_opacity.text()
        }
        
        item = self.layer_rule_tree.currentItem()
        if item:
            idx = self.layer_rule_tree.indexOfTopLevelItem(item)
            self.layer_rules_data[idx] = data
        else:
            self.layer_rules_data.append(data)
        
        self.refresh_layer_rules_tree_labels()

    def refresh_layer_rules_tree_labels(self):
        self.layer_rule_tree.clear()
        for d in self.layer_rules_data:
            label = "Rule"
            if d['namespace']: label += f" ns='{d['namespace']}'"
            if d['id']: label += f" id='{d['id']}'"
            QTreeWidgetItem(self.layer_rule_tree, [label])

    def del_layer_rule(self):
        item = self.layer_rule_tree.currentItem()
        if not item: return
        idx = self.layer_rule_tree.indexOfTopLevelItem(item)
        del self.layer_rules_data[idx]
        self.refresh_layer_rules_tree_labels()

    def save_layer_rules(self):
        block = ""
        for d in self.layer_rules_data:
            block += "layer-rule {\n"
            matchers = []
            if d['namespace']: matchers.append(f'namespace="{d["namespace"]}"')
            if d['id']: matchers.append(f'id="{d["id"]}"')
            
            if matchers:
                block += f"    match {' '.join(matchers)}\n"
            
            if d['block_out']: block += f'    block-out-from "{d["block_out"]}"\n'
            if d['corner']: block += f'    geometry-corner-radius {d["corner"]}\n'
            if d['opacity']: block += f'    opacity {d["opacity"]}\n'
            block += "}\n\n"
        
        self.handler.replace_layer_rules_section(block)

    def create_window_rules_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.rule_tree = QTreeWidget()
        self.rule_tree.setHeaderLabels(["Rule Matcher"])
        split.addWidget(self.rule_tree)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        w = QWidget()
        scroll.setWidget(w)
        l = QFormLayout(w)
        
        # Matchers
        gb_match = QGroupBox("Match Criteria")
        lm = QFormLayout(gb_match)
        self.wr_app_id = QLineEdit()
        self.wr_title = QLineEdit()
        self.wr_is_focused = QCheckBox("Is Focused") 
        lm.addRow("App ID (Regex)", self.wr_app_id)
        lm.addRow("Title (Regex)", self.wr_title)
        lm.addRow("", self.wr_is_focused)
        l.addRow(gb_match)
        
        # Geometry / Appearance
        gb_geo = QGroupBox("Geometry & Appearance")
        lg = QFormLayout(gb_geo)
        self.wr_opacity = QLineEdit()
        self.wr_corner_radius = QLineEdit()
        self.wr_clip_geo = QCheckBox("Clip to Geometry")
        self.wr_draw_border_bg = QCheckBox("Draw Border w/ Background")
        lg.addRow("Opacity (0.0-1.0)", self.wr_opacity)
        lg.addRow("Corner Radius", self.wr_corner_radius)
        lg.addRow("", self.wr_clip_geo)
        lg.addRow("", self.wr_draw_border_bg)
        l.addRow(gb_geo)

        # Behavior
        gb_beh = QGroupBox("Behavior")
        lb = QFormLayout(gb_beh)
        self.wr_open_max = QCheckBox("Open Maximized")
        self.wr_open_full = QCheckBox("Open Fullscreen")
        self.wr_open_float = QCheckBox("Open Floating")
        self.wr_default_col_width = QLineEdit() # e.g. "proportion 0.5"
        self.wr_open_output = QComboBox()
        self.wr_open_output.setEditable(True)
        self.wr_open_output.addItems(self.sys_outputs)
        
        lb.addRow("", self.wr_open_max)
        lb.addRow("", self.wr_open_full)
        lb.addRow("", self.wr_open_float)
        lb.addRow("Def. Col Width", self.wr_default_col_width)
        lb.addRow("Open on Output", self.wr_open_output)
        l.addRow(gb_beh)
        
        # Misc
        gb_misc = QGroupBox("Misc")
        lmi = QFormLayout(gb_misc)
        self.wr_block_out = QComboBox()
        self.wr_block_out.addItems(["", "screencast"])
        lmi.addRow("Block Out From", self.wr_block_out)
        l.addRow(gb_misc)
        
        # Buttons
        btn_update = QPushButton("Update / Add Rule")
        btn_update.clicked.connect(self.save_rule_mem)
        l.addRow(btn_update)
        
        btn_del = QPushButton("Delete Selected")
        btn_del.clicked.connect(self.del_rule)
        l.addRow(btn_del)
        
        split.addWidget(scroll)
        self.add_tab(split, "Rules")
        
        self.rule_tree.itemSelectionChanged.connect(self.on_rule_select)
        self.reload_rules()

    def reload_rules(self):
        self.rule_tree.clear()
        self.rules_data = [] # Clear internal memory
        
        raw_rules = self.handler.extract_window_rules()
        for r in raw_rules:
            c = r['content']
            data = {
                'app_id': '', 'title': '', 'is_focused': False,
                'opacity': '', 'corner': '', 'clip': False, 'border_bg': False,
                'max': False, 'full': False, 'float': False, 'col_width': '', 'output': '',
                'block_out': ''
            }
            
            # Parsing (simplified regex)
            m_app = re.search(r'app-id="([^"]+)"', c); 
            if m_app: data['app_id'] = m_app.group(1)
            
            m_tit = re.search(r'title="([^"]+)"', c); 
            if m_tit: data['title'] = m_tit.group(1)
            
            if "is-focused true" in c: data['is_focused'] = True
            
            m_op = re.search(r'opacity\s+([\d\.]+)', c); 
            if m_op: data['opacity'] = m_op.group(1)
            
            m_cr = re.search(r'geometry-corner-radius\s+([\d\.]+)', c); 
            if m_cr: data['corner'] = m_cr.group(1)
            
            if "clip-to-geometry true" in c: data['clip'] = True
            if "draw-border-with-background true" in c: data['border_bg'] = True
            if "open-maximized true" in c: data['max'] = True
            if "open-fullscreen true" in c: data['full'] = True
            if "open-floating true" in c: data['float'] = True
            
            m_cw = re.search(r'default-column-width\s+\{(.*)\}', c)
            if m_cw: data['col_width'] = m_cw.group(1).strip()
            
            m_out = re.search(r'open-on-output\s+"([^"]+)"', c)
            if m_out: data['output'] = m_out.group(1)
            
            m_blk = re.search(r'block-out-from\s+"([^"]+)"', c)
            if m_blk: data['block_out'] = m_blk.group(1)
            
            self.rules_data.append(data)
            
            # Label
            lbl = "Rule"
            if data['app_id']: lbl += f" app='{data['app_id']}'"
            elif data['title']: lbl += f" title='{data['title']}'"
            QTreeWidgetItem(self.rule_tree, [lbl])

    def on_rule_select(self):
        item = self.rule_tree.currentItem()
        if not item: return
        idx = self.rule_tree.indexOfTopLevelItem(item)
        if idx < 0 or idx >= len(self.rules_data): return
        
        d = self.rules_data[idx]
        self.wr_app_id.setText(d['app_id'])
        self.wr_title.setText(d['title'])
        self.wr_is_focused.setChecked(d['is_focused'])
        self.wr_opacity.setText(d['opacity'])
        self.wr_corner_radius.setText(d['corner'])
        self.wr_clip_geo.setChecked(d['clip'])
        self.wr_draw_border_bg.setChecked(d['border_bg'])
        self.wr_open_max.setChecked(d['max'])
        self.wr_open_full.setChecked(d['full'])
        self.wr_open_float.setChecked(d['float'])
        self.wr_default_col_width.setText(d['col_width'])
        self.wr_open_output.setCurrentText(d['output'])
        self.wr_block_out.setCurrentText(d['block_out'])

    def save_rule_mem(self):
        data = {
            'app_id': self.wr_app_id.text(),
            'title': self.wr_title.text(),
            'is_focused': self.wr_is_focused.isChecked(),
            'opacity': self.wr_opacity.text(),
            'corner': self.wr_corner_radius.text(),
            'clip': self.wr_clip_geo.isChecked(),
            'border_bg': self.wr_draw_border_bg.isChecked(),
            'max': self.wr_open_max.isChecked(),
            'full': self.wr_open_full.isChecked(),
            'float': self.wr_open_float.isChecked(),
            'col_width': self.wr_default_col_width.text(),
            'output': self.wr_open_output.currentText(),
            'block_out': self.wr_block_out.currentText()
        }
        
        item = self.rule_tree.currentItem()
        if item:
            idx = self.rule_tree.indexOfTopLevelItem(item)
            self.rules_data[idx] = data
        else:
            self.rules_data.append(data)
        
        self.refresh_rules_tree_labels()

    def refresh_rules_tree_labels(self):
        self.rule_tree.clear()
        for d in self.rules_data:
            lbl = "Rule"
            if d['app_id']: lbl += f" app='{d['app_id']}'"
            elif d['title']: lbl += f" title='{d['title']}'"
            QTreeWidgetItem(self.rule_tree, [lbl])

    def del_rule(self):
        item = self.rule_tree.currentItem()
        if not item: return
        idx = self.rule_tree.indexOfTopLevelItem(item)
        del self.rules_data[idx]
        self.refresh_rules_tree_labels()

    def save_rules(self):
        block = ""
        for d in self.rules_data:
            block += "window-rule {\n"
            
            # Matchers
            matchers = []
            if d['app_id']: matchers.append(f'app-id="{d["app_id"]}"')
            if d['title']: matchers.append(f'title="{d["title"]}"')
            if d['is_focused']: matchers.append("is-focused=true")
            
            if matchers:
                block += f"    match {' '.join(matchers)}\n"
            
            # Props
            if d['opacity']: block += f"    opacity {d['opacity']}\n"
            if d['corner']: block += f"    geometry-corner-radius {d['corner']}\n"
            if d['clip']: block += "    clip-to-geometry true\n"
            if d['border_bg']: block += "    draw-border-with-background true\n"
            if d['max']: block += "    open-maximized true\n"
            if d['full']: block += "    open-fullscreen true\n"
            if d['float']: block += "    open-floating true\n"
            if d['col_width']: block += f"    default-column-width {{ {d['col_width']} }}\n"
            if d['output']: block += f'    open-on-output "{d["output"]}"\n'
            if d['block_out']: block += f'    block-out-from "{d["block_out"]}"\n'
            
            block += "}\n\n"
        
        self.handler.replace_window_rules_section(block)

    def create_animations_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Off", "animations", "off", "false", is_bool=True)
        self.create_form_row(l, "Slowdown", "animations", "slowdown", "1.0")
        self.add_tab(w, "Animations")
    def create_debug_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Overlay", "debug", "enable-overlay", "false", is_bool=True)
        self.create_form_row(l, "DRM Device", "debug", "render-drm-device", "", options=self.sys_drm)
        self.add_tab(w, "Debug")

    def create_raw_tab(self):
        self.raw_editor = CodeEditor()
        self.raw_editor.setPlainText(self.handler.content)
        self.add_tab(self.raw_editor, "Full Config")

    def toggle_theme(self):
        self.is_dark = not self.is_dark
        self.apply_theme()
        if hasattr(self, 'raw_editor'): self.raw_editor.set_theme(self.is_dark)

    def apply_theme(self):
        palette = QPalette()
        if self.is_dark:
            palette.setColor(QPalette.Window, QColor(53, 53, 53))
            palette.setColor(QPalette.WindowText, Qt.white)
            palette.setColor(QPalette.Base, QColor(25, 25, 25))
            palette.setColor(QPalette.Text, Qt.white)
            palette.setColor(QPalette.Button, QColor(53, 53, 53))
            palette.setColor(QPalette.ButtonText, Qt.white)
            palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
            palette.setColor(QPalette.HighlightedText, Qt.black)
        else:
            palette = QApplication.style().standardPalette()
        QApplication.setPalette(palette)

    def update_config_list(self):
        self.combo_load.clear()
        self.configs = self.handler.list_configs()
        for name, _ in self.configs: self.combo_load.addItem(name)

    def on_config_selected(self, idx):
        if idx >= 0:
            self.handler.load_config(Path(self.configs[idx][1]))
            self.reload_settings()

    def prompt_save(self):
        reply = QMessageBox.question(self, 'Save', 'Overwrite config?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.save_settings()

    def save_settings(self):
        # 1. Update simple widgets
        for key, (widget, getter) in self.widget_map.items():
            path, k = key.split(":")
            self.handler.set_value(path, k, getter())
            
        # 2. Update Complex Blocks
        self.save_outputs()
        self.save_ws()
        self.save_binds()
        self.save_spawns()
        self.save_env()
        self.save_layer_rules()
        self.save_rules()
        self.save_switches()
        self.save_includes()

        # 3. Raw override if active
        if self.tabs.currentWidget() == self.raw_editor:
            self.handler.content = self.raw_editor.toPlainText()

        self.handler.create_backup()
        self.handler.save_config()
        self.update_config_list()
        QMessageBox.information(self, "Saved", "Configuration Saved!")

    def reload_settings(self):
        self.handler.load_config()
        for key, (widget, getter) in self.widget_map.items():
            path, k = key.split(":")
            val = self.handler.get_value(path, k, "")
            if isinstance(widget, QCheckBox): widget.setChecked(val.lower() == "true")
            elif isinstance(widget, QLineEdit): widget.setText(str(val))
            elif isinstance(widget, QComboBox): widget.setCurrentText(str(val))
        
        self.raw_editor.setPlainText(self.handler.content)
        self.reload_outputs()
        self.reload_ws()
        self.reload_binds()
        self.reload_spawns()
        self.reload_env()
        self.reload_layer_rules()
        self.reload_rules()
        self.reload_switches()
        self.reload_includes()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = NiriWindow()
    win.show()
    sys.exit(app.exec_())