#!/usr/bin/env python3
import sys
import os
import re
import subprocess
import glob
import shutil
import traceback
from pathlib import Path
from datetime import datetime

try:
    from PyQt5.QtWidgets import (
        QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
        QTabWidget, QLabel, QLineEdit, QComboBox, QCheckBox, QPushButton, 
        QTextEdit, QPlainTextEdit, QSplitter, QTreeWidget, QTreeWidgetItem, 
        QHeaderView, QFormLayout, QScrollArea, QMessageBox, QFileDialog, 
        QColorDialog, QFrame, QSizePolicy, QAction, QGroupBox, QSpinBox
    )
    from PyQt5.QtCore import Qt, QRect, QSize, pyqtSignal, pyqtSlot
    from PyQt5.QtGui import QColor, QPainter, QTextFormat, QPalette, QFont
except ImportError:
    print("Error: PyQt5 not found. Please install it (e.g., 'sudo pacman -S python-pyqt5' or 'pip install PyQt5').")
    sys.exit(1)

# ==============================================================================
# CONSTANTS & DEFAULTS
# ==============================================================================
NIRI_ACTIONS = [
    "quit", "close-window", "power-off-monitors", "show-hotkey-overlay",
    "focus-window-history-down", "focus-window-history-up",
    "focus-column-left", "focus-column-right", "focus-window-up", "focus-window-down",
    "move-column-left", "move-column-right", "move-window-up", "move-window-down",
    "focus-workspace-down", "focus-workspace-up", 
    "move-column-to-workspace-down", "move-column-to-workspace-up",
    "focus-monitor-left", "focus-monitor-right", "focus-monitor-down", "focus-monitor-up",
    "move-column-to-monitor-left", "move-column-to-monitor-right", 
    "move-column-to-monitor-down", "move-column-to-monitor-up",
    "maximize-column", "fullscreen-window", "center-column", 
    "set-column-width", "switch-preset-column-width",
    "consume-window-into-column", "expel-window-from-column",
    "screenshot", "screenshot-screen", "screenshot-window"
]

DEFAULT_CONFIG = """
// Niri Default Configuration
// Auto-generated by NiCoEd

input {
    keyboard {
        xkb {
            layout "us"
        }
    }
    touchpad {
        tap
        natural-scroll
        dwt
    }
    focus-follows-mouse
}

output "eDP-1" {
    scale 1.0
    transform "normal"
    position x=0 y=0
}

layout {
    gaps 16
    center-focused-column "never"
    default-column-width { proportion 0.5; }

    focus-ring {
        width 4
        active-color "#7fc8ff"
        inactive-color "#505050"
    }

    border {
        off
        width 4
        active-color "#ffc87f"
        inactive-color "#505050"
    }
}

binds {
    Mod+Shift+E { quit; }
    Mod+Q { close-window; }
}
"""

# ==============================================================================
# LOGIC: Config Handler
# ==============================================================================
class NiriConfigHandler:
    def __init__(self):
        self.config_path = self.get_config_path()
        self.content = ""
        self.load_config()

    def get_config_path(self):
        return Path.home() / ".config" / "niri" / "config.kdl"

    def load_config(self, filepath=None):
        target = filepath if filepath else self.config_path
        if target.exists():
            with open(target, "r") as f:
                self.content = f.read()
            return True
        else:
            self.content = DEFAULT_CONFIG
            return False

    def save_config(self):
        self.config_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.config_path, "w") as f:
            f.write(self.content)

    def create_backup(self):
        if not self.config_path.exists(): return None
        base_bak = self.config_path.with_name("config.kdl.bak")
        target_bak = base_bak
        count = 1
        while target_bak.exists():
            target_bak = self.config_path.with_name(f"config.kdl.bak{count}")
            count += 1
        try:
            shutil.copy2(self.config_path, target_bak)
            return target_bak.name
        except Exception as e:
            print(f"Backup failed: {e}")
            return None

    def list_configs(self):
        configs = []
        if self.config_path.exists():
            timestamp = datetime.fromtimestamp(self.config_path.stat().st_mtime).strftime("%H:%M:%S")
            configs.append((f"Current Config ({timestamp})", str(self.config_path)))
        parent = self.config_path.parent
        if parent.exists():
            backups = list(parent.glob("config.kdl.bak*"))
            backups.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            for bak in backups:
                ts = datetime.fromtimestamp(bak.stat().st_mtime).strftime("%Y-%m-%d %H:%M")
                configs.append((f"{bak.name} ({ts})", str(bak)))
        return configs

    def extract_block_content(self, text, block_name):
        pattern = re.compile(rf"\b{block_name}\b.*\{{")
        match = pattern.search(text)
        if not match: return None
        start_idx = match.start()
        open_brace_idx = match.end() - 1
        brace_count = 1
        i = open_brace_idx + 1
        while i < len(text) and brace_count > 0:
            if text[i] == '{': brace_count += 1
            elif text[i] == '}': brace_count -= 1
            i += 1
        if brace_count == 0: return (start_idx, i, text[open_brace_idx+1:i-1])
        return None

    def update_block(self, block_name, new_inner_content):
        result = self.extract_block_content(self.content, block_name)
        if result:
            start_idx, end_idx, _ = result
            brace_pos = self.content.find('{', start_idx)
            header = self.content[start_idx:brace_pos+1]
            self.content = self.content[:start_idx] + f"{header}\n{new_inner_content}\n}}" + self.content[end_idx:]
        else:
            self.content += f"\n{block_name} {{\n{new_inner_content}\n}}\n"

    def extract_repeated_blocks(self, block_name):
        blocks = []
        pattern = re.compile(rf'{block_name}\s+"([^"]+)"\s*\{{')
        text = self.content; search_start = 0
        while True:
            match = pattern.search(text, search_start)
            if not match: break
            name = match.group(1); brace_open_idx = match.end() - 1; brace_count = 1; i = brace_open_idx + 1
            while i < len(text) and brace_count > 0:
                if text[i] == '{': brace_count += 1
                elif text[i] == '}': brace_count -= 1
                i += 1
            if brace_count == 0:
                end_idx = i; inner = text[brace_open_idx+1 : end_idx-1]
                blocks.append({'name': name, 'content': inner, 'span': (match.start(), end_idx)})
                search_start = end_idx
            else: break
        return blocks

    def replace_repeated_blocks(self, block_name, new_blocks_str):
        current_blocks = self.extract_repeated_blocks(block_name)
        current_blocks.sort(key=lambda x: x['span'][0], reverse=True)
        for b in current_blocks: self.content = self.content[:b['span'][0]] + self.content[b['span'][1]:]
        self.content = self.content.rstrip() + "\n\n" + new_blocks_str

    def extract_rules(self, rule_type):
        rules = []
        pattern = re.compile(rf'\n\s*{rule_type}\s*\{{')
        text = self.content; search_start = 0
        while True:
            match = pattern.search(text, search_start)
            if not match: break
            brace_open_idx = match.end() - 1; brace_count = 1; i = brace_open_idx + 1
            while i < len(text) and brace_count > 0:
                if text[i] == '{': brace_count += 1
                elif text[i] == '}': brace_count -= 1
                i += 1
            if brace_count == 0:
                end_idx = i; inner = text[brace_open_idx+1 : end_idx-1]
                rules.append({'content': inner, 'span': (match.start(), end_idx)})
                search_start = end_idx
            else: break
        return rules

    def replace_rules(self, rule_type, new_blocks_str):
        current_rules = self.extract_rules(rule_type)
        current_rules.sort(key=lambda x: x['span'][0], reverse=True)
        for r in current_rules: self.content = self.content[:r['span'][0]] + self.content[r['span'][1]:]
        self.content = self.content.rstrip() + "\n\n" + new_blocks_str

    def extract_all_outputs(self): return self.extract_repeated_blocks("output")
    def replace_outputs_section(self, s): self.replace_repeated_blocks("output", s)
    def extract_named_workspaces(self): return self.extract_repeated_blocks("workspace")
    def replace_named_workspaces_section(self, s): self.replace_repeated_blocks("workspace", s)
    def extract_window_rules(self): return self.extract_rules("window-rule")
    def replace_window_rules_section(self, s): self.replace_rules("window-rule", s)
    def extract_layer_rules(self): return self.extract_rules("layer-rule")
    def replace_layer_rules_section(self, s): self.replace_rules("layer-rule", s)
    
    def extract_spawn_actions(self):
        actions = []
        pattern = re.compile(r'^\s*(spawn-at-startup|spawn-sh-at-startup)\s+(?:\"([^\"]*)\"|([^;\s]+))', re.MULTILINE)
        for m in pattern.finditer(self.content):
            actions.append({'type': m.group(1), 'command': m.group(2) or m.group(3)})
        return actions

    def replace_spawn_actions(self, new_actions):
        self.content = re.sub(r'^\s*(spawn-at-startup|spawn-sh-at-startup)\s+.*(\r\n|\r|\n)?', '', self.content, flags=re.MULTILINE)
        new_block = "\n"
        for act in new_actions: new_block += f"{act['type']} \"{act['command']}\"\n"
        self.content += new_block

    def extract_environment_vars(self):
        vars_list = []
        result = self.extract_block_content(self.content, "environment")
        if not result: return []
        for line in result[2].split('\n'):
            line = line.strip().strip(';')
            if not line or line.startswith("//"): continue
            parts = line.split(maxsplit=1)
            if len(parts) == 2: vars_list.append({'name': parts[0], 'value': parts[1].strip('"')})
        return vars_list

    def replace_environment_section(self, vars_list):
        inner = ""
        for v in vars_list: inner += f"    {v['name']} \"{v['value']}\"\n"
        self.update_block("environment", inner)

    def extract_includes(self):
        return [m.group(1) for m in re.finditer(r'^\s*include\s+"([^"]+)"', self.content, re.MULTILINE)]

    def replace_includes(self, new_includes):
        self.content = re.sub(r'^\s*include\s+"[^"]+".*(\r\n|\r|\n)?', '', self.content, flags=re.MULTILINE)
        block = ""
        for inc in new_includes: block += f'include "{inc}"\n'
        self.content = block + "\n" + self.content.strip()

    def get_value(self, path, key, default):
        current_text = self.content
        if path:
            blocks = path.split(".")
            for b in blocks:
                result = self.extract_block_content(current_text, b)
                if result: _, _, inner = result; current_text = inner
                else: return default
        match = re.search(rf"\b{key}\s+(?:\"([^\"]*)\"|([^;\s]+))", current_text)
        if match: return match.group(1) if match.group(1) is not None else match.group(2)
        if default in ["true", "false"]: return "true" if re.search(rf"\b{key}[;\s]", current_text) else "false"
        return default

    def set_value(self, path, key, value, is_string=False):
        self.content = self._update_recursive(self.content, path.split(".") if path else [], key, value, is_string)

    def _update_recursive(self, text, block_path, key, value, is_string):
        if not block_path:
            val_str = f'"{value}"' if is_string else str(value)
            if value.lower() == "true" and not is_string:
                if not re.search(rf"\b{key}[;\s]", text): return text.rstrip() + f"\n    {key};\n"
                return text 
            elif value.lower() == "false" and not is_string:
                return re.sub(rf"\s*{key}[;\s]", "", text)
            line = f"    {key} {val_str};\n"
            if re.search(rf"(\b{key}\s+)[^;]+;", text): return re.sub(rf"(\b{key}\s+)[^;]+;", rf"\1{val_str};", text)
            else: return text.rstrip() + "\n" + line

        current = block_path[0]
        result = self.extract_block_content(text, current)
        if result:
            s, e, inner = result
            new_inner = self._update_recursive(inner, block_path[1:], key, value, is_string)
            header = text[s : text.find('{', s)+1]
            return text[:s] + f"{header}{new_inner}}}" + text[e:]
        else:
            child = self._create_new_block(block_path[1:], key, value, is_string)
            return text + f"\n{current} {{\n{child}}}\n"

    def _create_new_block(self, block_path, key, value, is_string):
        if not block_path:
            val_str = f'"{value}"' if is_string else str(value)
            if value.lower() == "true": return f"    {key};\n"
            if value.lower() == "false": return ""
            return f"    {key} {val_str};\n"
        current = block_path[0]
        inner = self._create_new_block(block_path[1:], key, value, is_string)
        return f"    {current} {{\n{inner}    }}\n"

# ==============================================================================
# Hardware Info
# ==============================================================================
class SystemInfo:
    @staticmethod
    def get_connected_outputs():
        outputs = []
        try:
            res = subprocess.run(['niri', 'msg', '-j', 'outputs'], capture_output=True, text=True, timeout=1)
            if res.returncode == 0:
                import json; data = json.loads(res.stdout)
                for name in data.keys(): outputs.append(name)
        except: pass
        return outputs if outputs else ["eDP-1", "HDMI-A-1"]
    
    @staticmethod
    def get_drm_devices(): return glob.glob("/dev/dri/card*") or ["/dev/dri/card0"]

    @staticmethod
    def get_installed_cursor_themes():
        themes = set()
        for p in [Path.home()/".icons", Path.home()/".local/share/icons", Path("/usr/share/icons")]:
            if p.exists():
                for i in p.iterdir():
                    if (i/"cursors").exists() or (i/"index.theme").exists(): themes.add(i.name)
        return sorted(list(themes)) if themes else ["Adwaita", "default"]

# ==============================================================================
# CUSTOM WIDGETS
# ==============================================================================
class LineNumberArea(QWidget):
    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor
    def sizeHint(self): return QSize(self.editor.lineNumberAreaWidth(), 0)
    def paintEvent(self, event): self.editor.lineNumberAreaPaintEvent(event)

class CodeEditor(QPlainTextEdit):
    def __init__(self):
        super().__init__()
        self.lineNumberArea = LineNumberArea(self)
        self.blockCountChanged.connect(self.updateLineNumberAreaWidth)
        self.updateRequest.connect(self.updateLineNumberArea)
        self.cursorPositionChanged.connect(self.highlightCurrentLine)
        self.updateLineNumberAreaWidth(0)
        self.setFont(QFont("Monospace"))
        self.is_dark = False

    def lineNumberAreaWidth(self):
        digits = 1; max_val = max(1, self.blockCount())
        while max_val >= 10: max_val //= 10; digits += 1
        return 3 + self.fontMetrics().width('9') * digits

    def updateLineNumberAreaWidth(self, _):
        self.setViewportMargins(self.lineNumberAreaWidth(), 0, 0, 0)

    def updateLineNumberArea(self, rect, dy):
        if dy: self.lineNumberArea.scroll(0, dy)
        else: self.lineNumberArea.update(0, rect.y(), self.lineNumberArea.width(), rect.height())
        if rect.contains(self.viewport().rect()): self.updateLineNumberAreaWidth(0)

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.lineNumberArea.setGeometry(QRect(cr.left(), cr.top(), self.lineNumberAreaWidth(), cr.height()))

    def lineNumberAreaPaintEvent(self, event):
        painter = QPainter(self.lineNumberArea)
        painter.fillRect(event.rect(), Qt.lightGray if not self.is_dark else QColor("#2d2d2d"))
        block = self.firstVisibleBlock()
        blockNumber = block.blockNumber()
        top = int(self.blockBoundingGeometry(block).translated(self.contentOffset()).top())
        bottom = top + int(self.blockBoundingGeometry(block).height())
        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(blockNumber + 1)
                painter.setPen(Qt.black if not self.is_dark else Qt.lightGray)
                painter.drawText(0, top, self.lineNumberArea.width(), self.fontMetrics().height(), Qt.AlignRight, number)
            block = block.next(); top = bottom; bottom = top + int(self.blockBoundingGeometry(block).height()); blockNumber += 1

    def highlightCurrentLine(self):
        extraSelections = []
        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            lineColor = QColor(Qt.yellow).lighter(160) if not self.is_dark else QColor("#3d3d3d")
            selection.format.setBackground(lineColor)
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor(); selection.cursor.clearSelection()
            extraSelections.append(selection)
        self.setExtraSelections(extraSelections)
    
    def set_theme(self, is_dark):
        self.is_dark = is_dark
        p = self.palette()
        p.setColor(QPalette.Base, QColor("#1e1e1e") if is_dark else QColor("#ffffff"))
        p.setColor(QPalette.Text, QColor("#ffffff") if is_dark else QColor("#000000"))
        self.setPalette(p)
        self.highlightCurrentLine()
        self.update()

# ==============================================================================
# GUI: Main Window (PyQt5)
# ==============================================================================
class NiriWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("NiCoEd - Niri Config Editor")
        self.resize(1200, 850)
        
        self.handler = NiriConfigHandler()
        self.widget_map = {}
        
        # System Info
        self.sys_outputs = SystemInfo.get_connected_outputs()
        self.sys_cursors = SystemInfo.get_installed_cursor_themes()
        self.sys_drm = SystemInfo.get_drm_devices()
        
        # Central Layout
        self.central = QWidget(); self.setCentralWidget(self.central)
        self.layout = QVBoxLayout(self.central)
        
        self.tabs = QTabWidget(); self.layout.addWidget(self.tabs)
        
        # Footer
        self.lbl_info = QLabel("Ready.")
        self.layout.addWidget(self.lbl_info)
        
        btn_box = QHBoxLayout()
        self.btn_theme = QPushButton("ðŸŒ— Theme"); self.btn_theme.clicked.connect(self.toggle_theme)
        self.combo_load = QComboBox(); self.combo_load.currentIndexChanged.connect(self.on_config_selected)
        btn_reload = QPushButton("Reload"); btn_reload.clicked.connect(self.reload_settings)
        btn_save = QPushButton("Save All"); btn_save.clicked.connect(self.prompt_save)
        
        btn_box.addWidget(self.btn_theme)
        btn_box.addWidget(QLabel("Load:"))
        btn_box.addWidget(self.combo_load)
        btn_box.addStretch()
        btn_box.addWidget(btn_reload)
        btn_box.addWidget(btn_save)
        self.layout.addLayout(btn_box)
        
        self.init_tabs()
        self.update_config_list()
        self.is_dark = False; self.apply_theme()

    def init_tabs(self):
        self.create_input_tab()
        self.create_outputs_tab()
        self.create_layout_tab()
        self.create_workspaces_tab()
        self.create_cursor_tab()
        self.create_window_rules_tab()
        self.create_layer_rules_tab()
        self.create_animations_tab()
        self.create_misc_tab()
        self.create_environment_tab()
        self.create_debug_tab()
        self.create_binds_tab()
        self.create_switches_tab()
        self.create_gestures_tab()
        self.create_recent_windows_tab()
        self.create_includes_tab()
        self.create_raw_tab()

    def add_tab(self, widget, title):
        self.tabs.addTab(widget, title)

    def create_form_row(self, layout, label, path, key, default, is_bool=False, options=None, is_color=False, is_file=False):
        lbl = QLabel(label)
        val = self.handler.get_value(path, key, default)
        
        if is_bool:
            w = QCheckBox(); w.setChecked(val.lower() == "true")
            get = lambda: "true" if w.isChecked() else "false"
        elif options:
            w = QComboBox(); w.addItems(options); w.setCurrentText(val)
            get = lambda: w.currentText()
        else:
            w = QLineEdit(str(val))
            get = lambda: w.text()
            
        box = QHBoxLayout(); box.setContentsMargins(0,0,0,0); box.addWidget(w)
        if is_color:
            b = QPushButton("ðŸŽ¨"); b.clicked.connect(lambda: self.pick_color(w)); box.addWidget(b)
        if is_file:
            b = QPushButton("ðŸ“‚"); b.clicked.connect(lambda: self.pick_file(w)); box.addWidget(b)
            
        container = QWidget(); container.setLayout(box)
        layout.addRow(lbl, container)
        self.widget_map[f"{path}:{key}"] = (w, get)

    def pick_color(self, w):
        c = QColorDialog.getColor(); 
        if c.isValid(): w.setText(c.name())
    def pick_file(self, w):
        f, _ = QFileDialog.getOpenFileName(self, "Select"); 
        if f: w.setText(f)

    # --- TABS ---
    def create_input_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Warn Keymap", "input", "warn-no-keymap", "false", is_bool=True)
        self.create_form_row(l, "Power Key", "input", "power-key-action", "power-off", options=["power-off", "suspend", "interactive"])
        self.create_form_row(l, "Focus Mouse", "input", "focus-follows-mouse", "false", is_bool=True)
        
        l.addRow(QLabel("<b>Keyboard</b>"))
        self.create_form_row(l, "Layout", "input.keyboard.xkb", "layout", "us")
        self.create_form_row(l, "Repeat Delay", "input.keyboard", "repeat-delay", "600")
        self.create_form_row(l, "Repeat Rate", "input.keyboard", "repeat-rate", "25")
        
        l.addRow(QLabel("<b>Touchpad</b>"))
        self.create_form_row(l, "Tap Click", "input.touchpad", "tap", "false", is_bool=True)
        self.create_form_row(l, "Natural Scroll", "input.touchpad", "natural-scroll", "false", is_bool=True)
        self.create_form_row(l, "DWT", "input.touchpad", "dwt", "true", is_bool=True)
        self.create_form_row(l, "Click Method", "input.touchpad", "click-method", "button-areas", options=["button-areas", "clickfinger", "none"])
        
        self.add_tab(w, "Input")

    def create_outputs_tab(self):
        split = QSplitter(); self.out_tree = QTreeWidget(); self.out_tree.setHeaderLabels(["Output"])
        split.addWidget(self.out_tree)
        
        w = QWidget(); l = QFormLayout(w)
        self.out_mode = QComboBox(); self.out_mode.setEditable(True)
        self.out_scale = QLineEdit()
        self.out_trans = QComboBox(); self.out_trans.addItems(["normal", "90", "180", "270", "flipped"])
        self.out_pos = QLineEdit()
        
        l.addRow("Mode", self.out_mode); l.addRow("Scale", self.out_scale)
        l.addRow("Transform", self.out_trans); l.addRow("Position", self.out_pos)
        btn = QPushButton("Update / Add"); btn.clicked.connect(self.save_output_to_mem); l.addRow(btn)
        
        # Add Input
        self.new_out = QComboBox(); self.new_out.addItems(self.sys_outputs); self.new_out.setEditable(True)
        btn_add = QPushButton("Add New"); btn_add.clicked.connect(self.add_new_output); l.addRow(self.new_out, btn_add)
        btn_del = QPushButton("Delete Selected"); btn_del.clicked.connect(self.del_output); l.addRow(btn_del)
        
        split.addWidget(w); self.add_tab(split, "Outputs")
        self.out_tree.itemSelectionChanged.connect(self.on_out_select)
        self.reload_outputs()

    def reload_outputs(self):
        self.out_tree.clear()
        self.outputs_data = self.handler.extract_all_outputs()
        for o in self.outputs_data: QTreeWidgetItem(self.out_tree, [o['name']])

    def on_out_select(self):
        item = self.out_tree.currentItem()
        if not item: return
        name = item.text(0)
        data = next((x for x in self.outputs_data if x['name'] == name), None)
        if data:
            c = data['content']
            # Simple parse
            m = re.search(r'mode\s+"([^"]+)"', c); self.out_mode.setCurrentText(m.group(1) if m else "")
            s = re.search(r'scale\s+([\d\.]+)', c); self.out_scale.setText(s.group(1) if s else "1.0")
            t = re.search(r'transform\s+"([^"]+)"', c); self.out_trans.setCurrentText(t.group(1) if t else "normal")
            p = re.search(r'position\s+(.+)', c); self.out_pos.setText(p.group(1) if p else "")

    def save_output_to_mem(self):
        item = self.out_tree.currentItem()
        if not item: return
        name = item.text(0)
        c = f'    mode "{self.out_mode.currentText()}"\n    scale {self.out_scale.text()}\n    transform "{self.out_trans.currentText()}"\n'
        if self.out_pos.text(): c += f'    position {self.out_pos.text()}\n'
        
        for o in self.outputs_data:
            if o['name'] == name: o['content'] = c
        QMessageBox.information(self, "Updated", "Output updated in memory.")

    def add_new_output(self):
        name = self.new_out.currentText()
        if name:
            self.outputs_data.append({'name': name, 'content': '', 'span':(0,0)})
            self.reload_outputs()

    def del_output(self):
        item = self.out_tree.currentItem()
        if item:
            name = item.text(0)
            self.outputs_data = [o for o in self.outputs_data if o['name'] != name]
            self.reload_outputs()

    def save_outputs(self):
        block = ""
        for o in self.outputs_data: block += f'output "{o["name"]}" {{\n{o.get("content", "")}}}\n'
        self.handler.replace_outputs_section(block)

    def create_layout_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Gaps", "layout", "gaps", "16")
        self.create_form_row(l, "Border Width", "layout.border", "width", "4")
        self.create_form_row(l, "Active Color", "layout.border", "active-color", "#ff0000", is_color=True)
        self.create_form_row(l, "Focus Color", "layout.focus-ring", "active-color", "#7fc8ff", is_color=True)
        l.addRow(QLabel("<b>Tab Indicator</b>"))
        self.create_form_row(l, "Hide Single", "layout.tab-indicator", "hide-when-single", "false", is_bool=True)
        self.create_form_row(l, "Position", "layout.tab-indicator", "position", "top", options=["top", "bottom"])
        self.add_tab(w, "Layout")

    def create_workspaces_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.ws_tree = QTreeWidget(); self.ws_tree.setHeaderLabels(["Workspace"])
        split.addWidget(self.ws_tree)
        w = QWidget(); l = QFormLayout(w)
        self.ws_name = QLineEdit(); l.addRow("Name", self.ws_name)
        self.ws_out = QComboBox(); self.ws_out.addItems(self.sys_outputs)
        l.addRow("Output", self.ws_out)
        btn_add = QPushButton("Add/Update"); btn_add.clicked.connect(self.save_ws_mem); l.addRow(btn_add)
        btn_del = QPushButton("Delete"); btn_del.clicked.connect(self.del_ws); l.addRow(btn_del)
        split.addWidget(w)
        self.add_tab(split, "Workspaces")
        self.reload_ws()

    def reload_ws(self):
        self.ws_tree.clear()
        self.ws_data = self.handler.extract_named_workspaces()
        for w in self.ws_data: QTreeWidgetItem(self.ws_tree, [w['name']])
    
    def save_ws_mem(self):
        name = self.ws_name.text()
        if not name: return
        c = f'    open-on-output "{self.ws_out.currentText()}"\n'
        
        exists = False
        for w in self.ws_data:
            if w['name'] == name: w['content'] = c; exists = True
        if not exists: self.ws_data.append({'name': name, 'content': c, 'span':(0,0)})
        self.reload_ws()

    def del_ws(self):
        item = self.ws_tree.currentItem()
        if item:
            self.ws_data = [w for w in self.ws_data if w['name'] != item.text(0)]
            self.reload_ws()

    def save_ws(self):
        block = ""
        for w in self.ws_data: block += f'workspace "{w["name"]}" {{\n{w.get("content", "")}}}\n'
        self.handler.replace_named_workspaces_section(block)

    def create_cursor_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Theme", "", "xcursor-theme", "", options=self.sys_cursors)
        self.create_form_row(l, "Size", "", "xcursor-size", "24")
        self.add_tab(w, "Cursor")

    def create_binds_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.bind_tree = QTreeWidget(); self.bind_tree.setHeaderLabels(["Key", "Action"])
        split.addWidget(self.bind_tree)
        
        w = QWidget(); l = QVBoxLayout(w)
        
        gb = QGroupBox("Add/Edit Bind"); gl = QFormLayout(gb)
        self.bn_mod = QCheckBox("Mod"); self.bn_mod.setChecked(True)
        self.bn_s = QCheckBox("Shift"); self.bn_c = QCheckBox("Ctrl"); self.bn_a = QCheckBox("Alt")
        mod_box = QHBoxLayout(); mod_box.addWidget(self.bn_mod); mod_box.addWidget(self.bn_s); mod_box.addWidget(self.bn_c); mod_box.addWidget(self.bn_a)
        gl.addRow("Modifiers", mod_box)
        
        self.bn_key = QLineEdit(); gl.addRow("Key", self.bn_key)
        self.bn_act = QComboBox(); self.bn_act.addItems(NIRI_ACTIONS); self.bn_act.setEditable(True)
        gl.addRow("Action", self.bn_act)
        self.bn_spawn = QLineEdit(); gl.addRow("Spawn Cmd", self.bn_spawn)
        
        btn = QPushButton("Add/Update"); btn.clicked.connect(self.add_bind); gl.addRow(btn)
        l.addWidget(gb)
        btn_del = QPushButton("Delete Selected"); btn_del.clicked.connect(self.del_bind); l.addWidget(btn_del)
        l.addStretch()
        
        split.addWidget(w)
        self.add_tab(split, "Binds")
        self.reload_binds()

    def reload_binds(self):
        self.bind_tree.clear()
        res = self.handler.extract_block_content(self.handler.content, "binds")
        self.bind_data = []
        if res:
            for line in res[2].split('\n'):
                line = line.strip()
                if '{' in line:
                    k, a = line.split('{', 1)
                    k, a = k.strip(), a.strip(' }')
                    self.bind_data.append((k, a))
                    QTreeWidgetItem(self.bind_tree, [k, a])

    def add_bind(self):
        mods = []
        if self.bn_mod.isChecked(): mods.append("Mod")
        if self.bn_s.isChecked(): mods.append("Shift")
        if self.bn_c.isChecked(): mods.append("Ctrl")
        if self.bn_a.isChecked(): mods.append("Alt")
        k = "+".join(mods + [self.bn_key.text()])
        
        act = self.bn_act.currentText()
        if self.bn_spawn.text(): act = f'spawn "{self.bn_spawn.text()}"'
        if not act.endswith(';'): act += ";"
        
        self.bind_data.append((k, act))
        self.reload_binds_ui() # local reload

    def reload_binds_ui(self):
        self.bind_tree.clear()
        for k, a in self.bind_data: QTreeWidgetItem(self.bind_tree, [k, a])

    def del_bind(self):
        item = self.bind_tree.currentItem()
        if item:
            k = item.text(0)
            self.bind_data = [b for b in self.bind_data if b[0] != k]
            self.reload_binds_ui()

    def save_binds(self):
        block = ""
        for k, a in self.bind_data: block += f"    {k} {{ {a} }}\n"
        self.handler.update_block("binds", block)

    def create_misc_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Screenshot Path", "", "screenshot-path", "", is_file=True)
        self.create_form_row(l, "No CSD", "", "prefer-no-csd", "false", is_bool=True)
        
        # Spawns
        self.spawn_tree = QTreeWidget(); self.spawn_tree.setHeaderLabels(["Type", "Command"])
        l.addRow("Startups:", self.spawn_tree)
        self.sp_type = QComboBox(); self.sp_type.addItems(["spawn-at-startup", "spawn-sh-at-startup"])
        self.sp_cmd = QLineEdit()
        l.addRow(self.sp_type, self.sp_cmd)
        btn = QPushButton("Add Spawn"); btn.clicked.connect(self.add_spawn); l.addRow(btn)
        btn_d = QPushButton("Del Spawn"); btn_d.clicked.connect(self.del_spawn); l.addRow(btn_d)
        
        self.add_tab(w, "Misc")
        self.reload_spawns()

    def reload_spawns(self):
        self.spawn_tree.clear()
        self.spawn_data = self.handler.extract_spawn_actions()
        for s in self.spawn_data: QTreeWidgetItem(self.spawn_tree, [s['type'], s['command']])

    def add_spawn(self):
        self.spawn_data.append({'type': self.sp_type.currentText(), 'command': self.sp_cmd.text()})
        self.reload_spawns()
        
    def del_spawn(self):
        item = self.spawn_tree.currentItem()
        if item:
            cmd = item.text(1)
            self.spawn_data = [s for s in self.spawn_data if s['command'] != cmd]
            self.reload_spawns()
            
    def save_spawns(self):
        self.handler.replace_spawn_actions(self.spawn_data)

    def create_environment_tab(self):
        split = QSplitter(Qt.Horizontal)
        self.env_tree = QTreeWidget(); self.env_tree.setHeaderLabels(["Var", "Val"])
        split.addWidget(self.env_tree)
        w = QWidget(); l = QFormLayout(w)
        self.en_k = QLineEdit(); self.en_v = QLineEdit()
        l.addRow("Name", self.en_k); l.addRow("Value", self.en_v)
        btn = QPushButton("Add"); btn.clicked.connect(self.add_env); l.addRow(btn)
        btn_d = QPushButton("Delete"); btn_d.clicked.connect(self.del_env); l.addRow(btn_d)
        split.addWidget(w)
        self.add_tab(split, "Environment")
        self.reload_env()

    def reload_env(self):
        self.env_tree.clear()
        self.env_data = self.handler.extract_environment_vars()
        for e in self.env_data: QTreeWidgetItem(self.env_tree, [e['name'], e['value']])
    
    def add_env(self):
        self.env_data.append({'name': self.en_k.text(), 'value': self.en_v.text()})
        self.reload_env()
    def del_env(self):
        item = self.env_tree.currentItem()
        if item:
            self.env_data = [e for e in self.env_data if e['name'] != item.text(0)]
            self.reload_env()
    def save_env(self):
        self.handler.replace_environment_section(self.env_data)

    def create_window_rules_tab(self): self.add_tab(QLabel("Rules not fully implemented in GUI yet"), "Rules")
    def create_layer_rules_tab(self): self.add_tab(QLabel("Layers not fully implemented in GUI yet"), "Layers")
    def create_animations_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Off", "animations", "off", "false", is_bool=True)
        self.create_form_row(l, "Slowdown", "animations", "slowdown", "1.0")
        self.add_tab(w, "Animations")
    def create_debug_tab(self):
        w = QWidget(); l = QFormLayout(w)
        self.create_form_row(l, "Overlay", "debug", "enable-overlay", "false", is_bool=True)
        self.create_form_row(l, "DRM Device", "debug", "render-drm-device", "", options=self.sys_drm)
        self.add_tab(w, "Debug")
    def create_switches_tab(self): self.add_tab(QLabel("Switches Placeholder"), "Switches")
    def create_gestures_tab(self): self.add_tab(QLabel("Gestures Placeholder"), "Gestures")
    def create_recent_windows_tab(self): self.add_tab(QLabel("Recent Placeholder"), "Recent")
    def create_includes_tab(self): self.add_tab(QLabel("Includes Placeholder"), "Includes")

    def create_raw_tab(self):
        self.raw_editor = CodeEditor()
        self.raw_editor.setPlainText(self.handler.content)
        self.add_tab(self.raw_editor, "Full Config")

    def toggle_theme(self):
        self.is_dark = not self.is_dark
        self.apply_theme()
        if hasattr(self, 'raw_editor'): self.raw_editor.set_theme(self.is_dark)

    def apply_theme(self):
        palette = QPalette()
        if self.is_dark:
            palette.setColor(QPalette.Window, QColor(53, 53, 53))
            palette.setColor(QPalette.WindowText, Qt.white)
            palette.setColor(QPalette.Base, QColor(25, 25, 25))
            palette.setColor(QPalette.Text, Qt.white)
            palette.setColor(QPalette.Button, QColor(53, 53, 53))
            palette.setColor(QPalette.ButtonText, Qt.white)
            palette.setColor(QPalette.Highlight, QColor(42, 130, 218))
            palette.setColor(QPalette.HighlightedText, Qt.black)
        else:
            palette = QApplication.style().standardPalette()
        QApplication.setPalette(palette)

    def update_config_list(self):
        self.combo_load.clear()
        self.configs = self.handler.list_configs()
        for name, _ in self.configs: self.combo_load.addItem(name)

    def on_config_selected(self, idx):
        if idx >= 0:
            self.handler.load_config(Path(self.configs[idx][1]))
            self.reload_settings()

    def prompt_save(self):
        reply = QMessageBox.question(self, 'Save', 'Overwrite config?', QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if reply == QMessageBox.Yes:
            self.save_settings()

    def save_settings(self):
        # 1. Update simple widgets
        for key, (widget, getter) in self.widget_map.items():
            path, k = key.split(":")
            self.handler.set_value(path, k, getter())
            
        # 2. Update Complex Blocks
        self.save_outputs()
        self.save_ws()
        self.save_binds()
        self.save_spawns()
        self.save_env()
        # rules/layers/switches would go here

        # 3. Raw override if active
        if self.tabs.currentWidget() == self.raw_editor:
            self.handler.content = self.raw_editor.toPlainText()

        self.handler.create_backup()
        self.handler.save_config()
        self.update_config_list()
        QMessageBox.information(self, "Saved", "Configuration Saved!")

    def reload_settings(self):
        self.handler.load_config()
        for key, (widget, getter) in self.widget_map.items():
            path, k = key.split(":")
            val = self.handler.get_value(path, k, "")
            if isinstance(widget, QCheckBox): widget.setChecked(val.lower() == "true")
            elif isinstance(widget, QLineEdit): widget.setText(str(val))
            elif isinstance(widget, QComboBox): widget.setCurrentText(str(val))
        
        self.raw_editor.setPlainText(self.handler.content)
        self.reload_outputs()
        self.reload_ws()
        self.reload_binds()
        self.reload_spawns()
        self.reload_env()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    win = NiriWindow()
    win.show()
    sys.exit(app.exec_())